<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>How to implement - Emergent AI - Smart agents and events for games</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../../introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../../first_steps.html"><strong aria-hidden="true">2.</strong> First steps</a></li><li class="chapter-item expanded "><a href="../../decision_makers/introduction.html"><strong aria-hidden="true">3.</strong> Decision makers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../decision_makers/finite_state_machine/introduction.html"><strong aria-hidden="true">3.1.</strong> Finite State Machine</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../decision_makers/finite_state_machine/explanation.html"><strong aria-hidden="true">3.1.1.</strong> How it works</a></li><li class="chapter-item expanded "><a href="../../decision_makers/finite_state_machine/implementation.html"><strong aria-hidden="true">3.1.2.</strong> How to implement</a></li><li class="chapter-item expanded "><a href="../../decision_makers/finite_state_machine/use_of_machinery.html"><strong aria-hidden="true">3.1.3.</strong> Use of Machinery decision maker from emergent crate</a></li><li class="chapter-item expanded "><a href="../../decision_makers/finite_state_machine/usecases.html"><strong aria-hidden="true">3.1.4.</strong> Typical use cases</a></li></ol></li><li class="chapter-item expanded "><a href="../../decision_makers/hierarchical_finite_state_machine/introduction.html"><strong aria-hidden="true">3.2.</strong> Hierarchical Finite State Machine</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../decision_makers/hierarchical_finite_state_machine/explanation.html"><strong aria-hidden="true">3.2.1.</strong> How it works</a></li><li class="chapter-item expanded "><a href="../../decision_makers/hierarchical_finite_state_machine/implementation.html"><strong aria-hidden="true">3.2.2.</strong> How to implement</a></li><li class="chapter-item expanded "><a href="../../decision_makers/hierarchical_finite_state_machine/use_of_machinery.html"><strong aria-hidden="true">3.2.3.</strong> Hierarchical use of Machinery decision maker from emergent crate</a></li><li class="chapter-item expanded "><a href="../../decision_makers/hierarchical_finite_state_machine/usecases.html"><strong aria-hidden="true">3.2.4.</strong> Typical use cases</a></li></ol></li><li class="chapter-item expanded "><a href="../../decision_makers/utility_ai/introduction.html"><strong aria-hidden="true">3.3.</strong> Utility AI</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../decision_makers/utility_ai/explanation.html"><strong aria-hidden="true">3.3.1.</strong> How it works</a></li><li class="chapter-item expanded "><a href="../../decision_makers/utility_ai/implementation.html" class="active"><strong aria-hidden="true">3.3.2.</strong> How to implement</a></li><li class="chapter-item expanded "><a href="../../decision_makers/utility_ai/use_of_reasoner.html"><strong aria-hidden="true">3.3.3.</strong> Use of Reasoner decision maker from emergent crate</a></li><li class="chapter-item expanded "><a href="../../decision_makers/utility_ai/usecases.html"><strong aria-hidden="true">3.3.4.</strong> Typical use cases</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.4.</strong> Behavior Tree</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.5.</strong> Goal Oriented Action Planning</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Emergent gameplay</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">4.1.</strong> Emergent AI agents behavior</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.2.</strong> Emergent storytelling with AI-driven game events</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.3.</strong> Dreams and long-term memories impacting agent behavior</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Integrating AI systems into ECS frameworks</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Common AI problems and solutions</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.1.</strong> NPC day cycle</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.2.</strong> Steering</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.3.</strong> Crowd movement</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.4.</strong> Crowds shared behavior</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Let's create emergent gameplay together!</div></li><li class="chapter-item expanded "><a href="../../more.html"><strong aria-hidden="true">8.</strong> More...</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu (default)</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Emergent AI - Smart agents and events for games</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="how-to-implement"><a class="header" href="#how-to-implement">How to implement</a></h1>
<p>First we have to define alias types for <code>Score</code> and <code>Scorer</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Score = f32;
type Scorer&lt;T&gt; = fn(&amp;T) -&gt; Score;
<span class="boring">}
</span></code></pre></pre>
<p>We aliased <code>f32</code> as <code>Score</code> in case we would want to change it to <code>f64</code> at some
point and be able to perform that change only in alias declaration.</p>
<p><code>Scorer</code> is just an alias to function that will take context as input and produce
score as output, used later as state probability score for decision making.</p>
<p><code>State</code> trait stays the same as what we have made for FSM.</p>
<p>Next we define an <code>UtilityState</code> that will store an actual state and scorer:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::{collections::HashMap, hash::Hash};
</span><span class="boring">
</span><span class="boring">type Score = f32;
</span><span class="boring">type Scorer&lt;T&gt; = fn(&amp;T) -&gt; Score;
</span><span class="boring">
</span><span class="boring">trait State&lt;T&gt; {}
</span><span class="boring">
</span>struct UtilityState&lt;T&gt; {
  state: Box&lt;dyn State&lt;T&gt;&gt;,
  scorer: Scorer&lt;T&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>Now let's implement <code>Utility</code> decision maker:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::{collections::HashMap, hash::Hash};
</span><span class="boring">
</span><span class="boring">type Score = f32;
</span><span class="boring">type Scorer&lt;T&gt; = fn(&amp;T) -&gt; Score;
</span><span class="boring">
</span><span class="boring">trait State&lt;T&gt; {
</span><span class="boring">  fn activated(&amp;mut self, &amp;mut T) {}
</span><span class="boring">  fn decide(&amp;mut self, &amp;mut T) {}
</span><span class="boring">  fn update(&amp;mut self, &amp;mut T) {}
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct UtilityState&lt;T&gt; {
</span><span class="boring">  state: Box&lt;dyn State&lt;T&gt;&gt;,
</span><span class="boring">  scorer: Scorer&lt;T&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>struct Utility&lt;K, T&gt; {
  states: HashMap&lt;K, UtilityState&lt;T&gt;&gt;,
  active_state: K,
}

impl&lt;K: Hash + Eq, T&gt; Utility&lt;K, T&gt; {
  fn new(active_state: K) -&gt; Self {
    Self {
      states: Default::default(),
      active_state,
    }
  }

  fn state&lt;S&gt;(mut self, id: K, state: S, scorer: Scorer&lt;T&gt;) -&gt; Self
  where
    S: State&lt;T&gt; + 'static,
  {
    let state = UtilityState {
      state: Box::new(state),
      scorer,
    };
    self.states.insert(id, state);
    self
  }

  fn set_active_state(&amp;mut self, id: K, context: &amp;mut T, forced: bool) {
    if forced || id != self.active_state {
      if let Some(state) = self.states.get_mut(&amp;id) {
        state.state.activated(context);
        self.active_state = id;
      }
    }
  }

  fn decide(&amp;mut self, context: &amp;mut T) where K: Clone {
    let winner = self
      .states
      .iter()
      .map(|(k, v)| (k, (v.scorer)(context)))
      .max_by(|a, b| a.1.partial_cmp(&amp;b.1).unwrap())
      .map(|(id, _)| id.clone());
    if let Some(id) = winner {
      self.set_active_state(id, context, false);
    }
    if let Some(state) = self.states.get_mut(&amp;self.active_state) {
      state.state.decide(context);
    }
  }

  fn update(&amp;mut self, context: &amp;mut T) {
    if let Some(state) = self.states.get_mut(&amp;self.active_state) {
      state.state.update(context);
    }
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>Methods: <code>new</code>, <code>set_active_state</code> and <code>update</code> arent much different from what
we have done for FSM, but <code>decide</code> method changes completely, obviously.</p>
<p>It performs iterator operations suck as:</p>
<ul>
<li>First map each state ID and <code>UtilityState</code> into state ID and state score (by
executing scorer function with the context).</li>
<li>Then it finds an item wth the highest score using <code>max_by</code> iterator operation.</li>
<li>And finally it maps result to get only found state ID.</li>
</ul>
<p>Then if there is winner state ID found, sets active state to one selected (it
will change state only if new one is different than currently active state).</p>
<p>At the end it calls <code>decide</code> method on currently active state, to properly
propagate decision making in case we use <code>Utility</code> in hierarchy just like we did
with HFSM (yes, we are making <code>Utility</code> support hierarchies).</p>
<p>We also need to implement <code>State</code> trait for <code>Utility</code> type:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::{collections::HashMap, hash::Hash};
</span><span class="boring">
</span><span class="boring">type Score = f32;
</span><span class="boring">type Scorer&lt;T&gt; = fn(&amp;T) -&gt; Score;
</span><span class="boring">
</span><span class="boring">trait State&lt;T&gt; {
</span><span class="boring">  fn activated(&amp;mut self, &amp;mut T) {}
</span><span class="boring">  fn decide(&amp;mut self, &amp;mut T) {}
</span><span class="boring">  fn update(&amp;mut self, &amp;mut T) {}
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct UtilityState&lt;T&gt; {
</span><span class="boring">  state: Box&lt;dyn State&lt;T&gt;&gt;,
</span><span class="boring">  scorer: Scorer&lt;T&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Utility&lt;K, T&gt; {
</span><span class="boring">  states: HashMap&lt;K, UtilityState&lt;T&gt;&gt;,
</span><span class="boring">  active_state: K,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;K: Hash + Eq, T&gt; Utility&lt;K, T&gt; {
</span><span class="boring">  fn decide(&amp;mut self, context: &amp;mut T) where K: Clone {}
</span><span class="boring">  fn update(&amp;mut self, context: &amp;mut T) {}
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;K: Clone + Hash + Eq, T&gt; State&lt;T&gt; for Utility&lt;K, T&gt; {
  fn decide(&amp;mut self, context: &amp;mut T) {
    self.decide(context);
  }

  fn update(&amp;mut self, context: &amp;mut T) {
    self.update(context);
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>Ok, so we have completed <code>Utility</code> decision maker implementation, we can now make
state ID and data types for enemy:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
enum EnemyState {
  Idle,
  GatherFood,
  GatherWood,
  AttackOpponent,
}

struct EnemyData {
  hunger: f32,
  distance_to_food: f32,
  distance_to_trees: f32,
  wood_needed: usize,
  distance_to_opponent: f32,
  opponent_strength: f32,
}
<span class="boring">}
</span></code></pre></pre>
<p>We keep these types same as what we have defined in <a href="./explanation.html">explanation chapter</a>.</p>
<p>Now take a look how we can translate scorer operations for these states into
actual scoring functions:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">type Score = f32;
</span><span class="boring">
</span><span class="boring">struct EnemyData {
</span><span class="boring">  hunger: f32,
</span><span class="boring">  distance_to_food: f32,
</span><span class="boring">  distance_to_trees: f32,
</span><span class="boring">  wood_needed: usize,
</span><span class="boring">  distance_to_opponent: f32,
</span><span class="boring">  opponent_strength: f32,
</span><span class="boring">}
</span><span class="boring">
</span>fn scorer_idle(context: &amp;EnemyData) -&gt; Score {
  0.001
}

fn scorer_gather_food(context: &amp;EnemyData) -&gt; Score {
  context.hunger * (1.0 - context.distance_to_food)
}

fn scorer_gather_wood(context: &amp;EnemyData) -&gt; Score {
  let wood_needed = if context.wood_needed &gt; 0 { 1.0 } else { 0.0 };
  wood_needed * (1.0 - context.distance_to_trees)
}

fn scorer_attack_opponent(context: &amp;EnemyData) -&gt; Score {
  (1.0 - context.distance_to_opponent) + context.opponent_strength
}
<span class="boring">}
</span></code></pre></pre>
<p>Obviously if we would like to reuse parts of these scorers logic we can put these
operations into separate functions, the point is that all what matters is to
produce a single score, you can organize your scorers as you wish.</p>
<p>Next step is to implement enemy states that will mutate enemy data to reflect
changes in the world:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">type Score = f32;
</span><span class="boring">
</span><span class="boring">struct EnemyData {
</span><span class="boring">  hunger: f32,
</span><span class="boring">  distance_to_food: f32,
</span><span class="boring">  distance_to_trees: f32,
</span><span class="boring">  wood_needed: usize,
</span><span class="boring">  distance_to_opponent: f32,
</span><span class="boring">  opponent_strength: f32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait State&lt;T&gt; {
</span><span class="boring">  fn activated(&amp;mut self, &amp;mut T) {}
</span><span class="boring">  fn decide(&amp;mut self, &amp;mut T) {}
</span><span class="boring">  fn update(&amp;mut self, &amp;mut T) {}
</span><span class="boring">}
</span><span class="boring">
</span>struct EnemyIdleState;

impl State&lt;EnemyData&gt; for EnemyIdleState {}

struct EnemyGatherFoodState;

impl State&lt;EnemyData&gt; for EnemyGatherFoodState {
  fn activated(&amp;mut self, context: &amp;mut EnemyData) {
    context.hunger = 0.0;
    context.distance_to_food = 1.0;
  }
}

struct EnemyGatherWoodState;

impl State&lt;EnemyData&gt; for EnemyGatherWoodState {
  fn activated(&amp;mut self, context: &amp;mut EnemyData) {
    context.wood_needed = context.wood_needed.max(1) - 1;
    context.distance_to_trees = 1.0;
  }
}

struct EnemyAttackOpponentState;

impl State&lt;EnemyData&gt; for EnemyAttackOpponentState {
  fn activated(&amp;mut self, context: &amp;mut EnemyData) {
    context.distance_to_opponent = 1.0;
    context.opponent_strength = 0.0;
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>Finally we implement <code>Enemy</code> type itself and its <code>Utility</code> decision maker setup:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::{collections::HashMap, hash::Hash};
</span><span class="boring">
</span><span class="boring">type Score = f32;
</span><span class="boring">type Scorer&lt;T&gt; = fn(&amp;T) -&gt; Score;
</span><span class="boring">
</span><span class="boring">trait State&lt;T&gt; {
</span><span class="boring">  fn activated(&amp;mut self, &amp;mut T) {}
</span><span class="boring">  fn decide(&amp;mut self, &amp;mut T) {}
</span><span class="boring">  fn update(&amp;mut self, &amp;mut T) {}
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct UtilityState&lt;T&gt; {
</span><span class="boring">  state: Box&lt;dyn State&lt;T&gt;&gt;,
</span><span class="boring">  scorer: Scorer&lt;T&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Utility&lt;K, T&gt; {
</span><span class="boring">  states: HashMap&lt;K, UtilityState&lt;T&gt;&gt;,
</span><span class="boring">  active_state: K,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;K: Hash + Eq, T&gt; Utility&lt;K, T&gt; {
</span><span class="boring">  fn new(active_state: K) -&gt; Self {
</span><span class="boring">    Self {
</span><span class="boring">      states: Default::default(),
</span><span class="boring">      active_state,
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn state&lt;S&gt;(mut self, id: K, state: S, scorer: Scorer&lt;T&gt;) -&gt; Self
</span><span class="boring">  where
</span><span class="boring">    S: State&lt;T&gt; + 'static,
</span><span class="boring">  {
</span><span class="boring">    let state = UtilityState {
</span><span class="boring">      state: Box::new(state),
</span><span class="boring">      scorer,
</span><span class="boring">    };
</span><span class="boring">    self.states.insert(id, state);
</span><span class="boring">    self
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn set_active_state(&amp;mut self, id: K, context: &amp;mut T, forced: bool) {
</span><span class="boring">    if forced || id != self.active_state {
</span><span class="boring">      if let Some(state) = self.states.get_mut(&amp;id) {
</span><span class="boring">        state.state.activated(context);
</span><span class="boring">        self.active_state = id;
</span><span class="boring">      }
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn decide(&amp;mut self, context: &amp;mut T) where K: Clone {
</span><span class="boring">    let winner = self
</span><span class="boring">      .states
</span><span class="boring">      .iter()
</span><span class="boring">      .map(|(k, v)| (k, (v.scorer)(context)))
</span><span class="boring">      .max_by(|a, b| a.1.partial_cmp(&amp;b.1).unwrap())
</span><span class="boring">      .map(|(id, _)| id.clone());
</span><span class="boring">    if let Some(id) = winner {
</span><span class="boring">      self.set_active_state(id, context, false);
</span><span class="boring">    }
</span><span class="boring">    if let Some(state) = self.states.get_mut(&amp;self.active_state) {
</span><span class="boring">      state.state.decide(context);
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn update(&amp;mut self, context: &amp;mut T) {
</span><span class="boring">    if let Some(state) = self.states.get_mut(&amp;self.active_state) {
</span><span class="boring">      state.state.update(context);
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;K: Clone + Hash + Eq, T&gt; State&lt;T&gt; for Utility&lt;K, T&gt; {
</span><span class="boring">  fn decide(&amp;mut self, context: &amp;mut T) {
</span><span class="boring">    self.decide(context);
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn update(&amp;mut self, context: &amp;mut T) {
</span><span class="boring">    self.update(context);
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
</span><span class="boring">enum EnemyState {
</span><span class="boring">  Idle,
</span><span class="boring">  GatherFood,
</span><span class="boring">  GatherWood,
</span><span class="boring">  AttackOpponent,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct EnemyData {
</span><span class="boring">  hunger: f32,
</span><span class="boring">  distance_to_food: f32,
</span><span class="boring">  distance_to_trees: f32,
</span><span class="boring">  wood_needed: usize,
</span><span class="boring">  distance_to_opponent: f32,
</span><span class="boring">  opponent_strength: f32,
</span><span class="boring">}
</span><span class="boring">
</span>struct Enemy {
  data: EnemyData,
  utility: Utility&lt;EnemyState, EnemyData&gt;,
}

impl Enemy {
  fn new() -&gt; Self {
    let data = EnemyData {
      hunger: 0.0,
      distance_to_food: 1.0,
      distance_to_trees: 1.0,
      wood_needed: 0,
      distance_to_opponent: 1.0,
      opponent_strength: 0.0,
    };
    let utility = Utility::new(EnemyState::Idle)
      .state(EnemyState::Idle, EnemyIdleState, scorer_idle)
      .state(EnemyState::GatherFood, EnemyGatherFoodState, scorer_gather_food)
      .state(EnemyState::GatherWood, EnemyGatherWoodState, scorer_gather_wood)
      .state(
        EnemyState::AttackOpponent,
        EnemyAttackOpponentState,
        scorer_attack_opponent,
      );

    Self { data, utility }
  }

  fn tick(&amp;mut self) {
    self.utility.decide(&amp;mut self.data);
    self.utility.update(&amp;mut self.data);
  }
}
<span class="boring">
</span><span class="boring">fn scorer_idle(context: &amp;EnemyData) -&gt; Score {
</span><span class="boring">  0.001
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn scorer_gather_food(context: &amp;EnemyData) -&gt; Score {
</span><span class="boring">  context.hunger * (1.0 - context.distance_to_food)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn scorer_gather_wood(context: &amp;EnemyData) -&gt; Score {
</span><span class="boring">  let wood_needed = if context.wood_needed &gt; 0 { 1.0 } else { 0.0 };
</span><span class="boring">  wood_needed * (1.0 - context.distance_to_trees)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn scorer_attack_opponent(context: &amp;EnemyData) -&gt; Score {
</span><span class="boring">  (1.0 - context.distance_to_opponent) + context.opponent_strength
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct EnemyIdleState;
</span><span class="boring">
</span><span class="boring">impl State&lt;EnemyData&gt; for EnemyIdleState {}
</span><span class="boring">
</span><span class="boring">struct EnemyGatherFoodState;
</span><span class="boring">
</span><span class="boring">impl State&lt;EnemyData&gt; for EnemyGatherFoodState {
</span><span class="boring">  fn activated(&amp;mut self, context: &amp;mut EnemyData) {
</span><span class="boring">    context.hunger = 0.0;
</span><span class="boring">    context.distance_to_food = 1.0;
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct EnemyGatherWoodState;
</span><span class="boring">
</span><span class="boring">impl State&lt;EnemyData&gt; for EnemyGatherWoodState {
</span><span class="boring">  fn activated(&amp;mut self, context: &amp;mut EnemyData) {
</span><span class="boring">    context.wood_needed = context.wood_needed.max(1) - 1;
</span><span class="boring">    context.distance_to_trees = 1.0;
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct EnemyAttackOpponentState;
</span><span class="boring">
</span><span class="boring">impl State&lt;EnemyData&gt; for EnemyAttackOpponentState {
</span><span class="boring">  fn activated(&amp;mut self, context: &amp;mut EnemyData) {
</span><span class="boring">    context.distance_to_opponent = 1.0;
</span><span class="boring">    context.opponent_strength = 0.0;
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>And what's left is to test how enemy states react to changes in the world:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::{collections::HashMap, hash::Hash};
</span><span class="boring">
</span><span class="boring">type Score = f32;
</span><span class="boring">type Scorer&lt;T&gt; = fn(&amp;T) -&gt; Score;
</span><span class="boring">
</span><span class="boring">trait State&lt;T&gt; {
</span><span class="boring">  fn activated(&amp;mut self, &amp;mut T) {}
</span><span class="boring">  fn decide(&amp;mut self, &amp;mut T) {}
</span><span class="boring">  fn update(&amp;mut self, &amp;mut T) {}
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct UtilityState&lt;T&gt; {
</span><span class="boring">  state: Box&lt;dyn State&lt;T&gt;&gt;,
</span><span class="boring">  scorer: Scorer&lt;T&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Utility&lt;K, T&gt; {
</span><span class="boring">  states: HashMap&lt;K, UtilityState&lt;T&gt;&gt;,
</span><span class="boring">  active_state: K,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;K: Hash + Eq, T&gt; Utility&lt;K, T&gt; {
</span><span class="boring">  fn new(active_state: K) -&gt; Self {
</span><span class="boring">    Self {
</span><span class="boring">      states: Default::default(),
</span><span class="boring">      active_state,
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn state&lt;S&gt;(mut self, id: K, state: S, scorer: Scorer&lt;T&gt;) -&gt; Self
</span><span class="boring">  where
</span><span class="boring">    S: State&lt;T&gt; + 'static,
</span><span class="boring">  {
</span><span class="boring">    let state = UtilityState {
</span><span class="boring">      state: Box::new(state),
</span><span class="boring">      scorer,
</span><span class="boring">    };
</span><span class="boring">    self.states.insert(id, state);
</span><span class="boring">    self
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn set_active_state(&amp;mut self, id: K, context: &amp;mut T, forced: bool) {
</span><span class="boring">    if forced || id != self.active_state {
</span><span class="boring">      if let Some(state) = self.states.get_mut(&amp;id) {
</span><span class="boring">        state.state.activated(context);
</span><span class="boring">        self.active_state = id;
</span><span class="boring">      }
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn decide(&amp;mut self, context: &amp;mut T) where K: Clone {
</span><span class="boring">    let winner = self
</span><span class="boring">      .states
</span><span class="boring">      .iter()
</span><span class="boring">      .map(|(k, v)| (k, (v.scorer)(context)))
</span><span class="boring">      .max_by(|a, b| a.1.partial_cmp(&amp;b.1).unwrap())
</span><span class="boring">      .map(|(id, _)| id.clone());
</span><span class="boring">    if let Some(id) = winner {
</span><span class="boring">      self.set_active_state(id, context, false);
</span><span class="boring">    }
</span><span class="boring">    if let Some(state) = self.states.get_mut(&amp;self.active_state) {
</span><span class="boring">      state.state.decide(context);
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn update(&amp;mut self, context: &amp;mut T) {
</span><span class="boring">    if let Some(state) = self.states.get_mut(&amp;self.active_state) {
</span><span class="boring">      state.state.update(context);
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;K: Clone + Hash + Eq, T&gt; State&lt;T&gt; for Utility&lt;K, T&gt; {
</span><span class="boring">  fn decide(&amp;mut self, context: &amp;mut T) {
</span><span class="boring">    self.decide(context);
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn update(&amp;mut self, context: &amp;mut T) {
</span><span class="boring">    self.update(context);
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
</span><span class="boring">enum EnemyState {
</span><span class="boring">  Idle,
</span><span class="boring">  GatherFood,
</span><span class="boring">  GatherWood,
</span><span class="boring">  AttackOpponent,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct EnemyData {
</span><span class="boring">  hunger: f32,
</span><span class="boring">  distance_to_food: f32,
</span><span class="boring">  distance_to_trees: f32,
</span><span class="boring">  wood_needed: usize,
</span><span class="boring">  distance_to_opponent: f32,
</span><span class="boring">  opponent_strength: f32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Enemy {
</span><span class="boring">  data: EnemyData,
</span><span class="boring">  utility: Utility&lt;EnemyState, EnemyData&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Enemy {
</span><span class="boring">  fn new() -&gt; Self {
</span><span class="boring">    let data = EnemyData {
</span><span class="boring">      hunger: 0.0,
</span><span class="boring">      distance_to_food: 1.0,
</span><span class="boring">      distance_to_trees: 1.0,
</span><span class="boring">      wood_needed: 0,
</span><span class="boring">      distance_to_opponent: 1.0,
</span><span class="boring">      opponent_strength: 0.0,
</span><span class="boring">    };
</span><span class="boring">    let utility = Utility::new(EnemyState::Idle)
</span><span class="boring">      .state(EnemyState::Idle, EnemyIdleState, scorer_idle)
</span><span class="boring">      .state(EnemyState::GatherFood, EnemyGatherFoodState, scorer_gather_food)
</span><span class="boring">      .state(EnemyState::GatherWood, EnemyGatherWoodState, scorer_gather_wood)
</span><span class="boring">      .state(
</span><span class="boring">        EnemyState::AttackOpponent,
</span><span class="boring">        EnemyAttackOpponentState,
</span><span class="boring">        scorer_attack_opponent,
</span><span class="boring">      );
</span><span class="boring">
</span><span class="boring">    Self { data, utility }
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn tick(&amp;mut self) {
</span><span class="boring">    self.utility.decide(&amp;mut self.data);
</span><span class="boring">    self.utility.update(&amp;mut self.data);
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn scorer_idle(context: &amp;EnemyData) -&gt; Score {
</span><span class="boring">  0.001
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn scorer_gather_food(context: &amp;EnemyData) -&gt; Score {
</span><span class="boring">  context.hunger * (1.0 - context.distance_to_food)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn scorer_gather_wood(context: &amp;EnemyData) -&gt; Score {
</span><span class="boring">  let wood_needed = if context.wood_needed &gt; 0 { 1.0 } else { 0.0 };
</span><span class="boring">  wood_needed * (1.0 - context.distance_to_trees)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn scorer_attack_opponent(context: &amp;EnemyData) -&gt; Score {
</span><span class="boring">  (1.0 - context.distance_to_opponent) + context.opponent_strength
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct EnemyIdleState;
</span><span class="boring">
</span><span class="boring">impl State&lt;EnemyData&gt; for EnemyIdleState {}
</span><span class="boring">
</span><span class="boring">struct EnemyGatherFoodState;
</span><span class="boring">
</span><span class="boring">impl State&lt;EnemyData&gt; for EnemyGatherFoodState {
</span><span class="boring">  fn activated(&amp;mut self, context: &amp;mut EnemyData) {
</span><span class="boring">    context.hunger = 0.0;
</span><span class="boring">    context.distance_to_food = 1.0;
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct EnemyGatherWoodState;
</span><span class="boring">
</span><span class="boring">impl State&lt;EnemyData&gt; for EnemyGatherWoodState {
</span><span class="boring">  fn activated(&amp;mut self, context: &amp;mut EnemyData) {
</span><span class="boring">    context.wood_needed = context.wood_needed.max(1) - 1;
</span><span class="boring">    context.distance_to_trees = 1.0;
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct EnemyAttackOpponentState;
</span><span class="boring">
</span><span class="boring">impl State&lt;EnemyData&gt; for EnemyAttackOpponentState {
</span><span class="boring">  fn activated(&amp;mut self, context: &amp;mut EnemyData) {
</span><span class="boring">    context.distance_to_opponent = 1.0;
</span><span class="boring">    context.opponent_strength = 0.0;
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span>let mut enemy = Enemy::new();
assert_eq!(enemy.utility.active_state, EnemyState::Idle);
assert_eq!(enemy.data.hunger, 0.0);
assert_eq!(enemy.data.distance_to_food, 1.0);
assert_eq!(enemy.data.distance_to_trees, 1.0);
assert_eq!(enemy.data.wood_needed, 0);
assert_eq!(enemy.data.distance_to_opponent, 1.0);
assert_eq!(enemy.data.opponent_strength, 0.0);

enemy.data.hunger = 0.5;
enemy.data.distance_to_food = 0.9;
enemy.data.distance_to_trees = 0.5;
enemy.data.opponent_strength = 0.2;

enemy.tick();
assert_eq!(enemy.utility.active_state, EnemyState::AttackOpponent);
assert_eq!(enemy.data.hunger, 0.5);
assert_eq!(enemy.data.distance_to_food, 0.9);
assert_eq!(enemy.data.distance_to_trees, 0.5);
assert_eq!(enemy.data.wood_needed, 0);
assert_eq!(enemy.data.distance_to_opponent, 1.0);
assert_eq!(enemy.data.opponent_strength, 0.0);

enemy.tick();
assert_eq!(enemy.utility.active_state, EnemyState::GatherFood);
assert_eq!(enemy.data.hunger, 0.0);
assert_eq!(enemy.data.distance_to_food, 1.0);
assert_eq!(enemy.data.distance_to_trees, 0.5);
assert_eq!(enemy.data.wood_needed, 0);
assert_eq!(enemy.data.distance_to_opponent, 1.0);
assert_eq!(enemy.data.opponent_strength, 0.0);

enemy.data.wood_needed = 1;

enemy.tick();
assert_eq!(enemy.utility.active_state, EnemyState::GatherWood);
assert_eq!(enemy.data.hunger, 0.0);
assert_eq!(enemy.data.distance_to_food, 1.0);
assert_eq!(enemy.data.distance_to_trees, 1.0);
assert_eq!(enemy.data.wood_needed, 0);
assert_eq!(enemy.data.distance_to_opponent, 1.0);
assert_eq!(enemy.data.opponent_strength, 0.0);

enemy.tick();
assert_eq!(enemy.utility.active_state, EnemyState::Idle);
assert_eq!(enemy.data.hunger, 0.0);
assert_eq!(enemy.data.distance_to_food, 1.0);
assert_eq!(enemy.data.distance_to_trees, 1.0);
assert_eq!(enemy.data.wood_needed, 0);
assert_eq!(enemy.data.distance_to_opponent, 1.0);
assert_eq!(enemy.data.opponent_strength, 0.0);
<span class="boring">}
</span></code></pre></pre>
<p>As you can see, all state changes are completely environment-driven - no fixed
transitions, fully emergent behavior.</p>
<p>Not much more is needed to be explained because most implmentation is very similar
if not the same, as with FSM, we just had to implement scoring feature for decision
making - that's how easy is to move from FSM to Utility AI!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../decision_makers/utility_ai/explanation.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../../decision_makers/utility_ai/use_of_reasoner.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../decision_makers/utility_ai/explanation.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../../decision_makers/utility_ai/use_of_reasoner.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
