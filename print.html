<!DOCTYPE HTML>
<html lang="en" class="ayu" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Emergent AI - Smart agents and events for games</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('ayu')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="first_steps.html"><strong aria-hidden="true">2.</strong> First steps</a></li><li class="chapter-item expanded "><a href="decision_makers/introduction.html"><strong aria-hidden="true">3.</strong> Decision makers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="decision_makers/finite_state_machine/introduction.html"><strong aria-hidden="true">3.1.</strong> Finite State Machine</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="decision_makers/finite_state_machine/explanation.html"><strong aria-hidden="true">3.1.1.</strong> How it works</a></li><li class="chapter-item expanded "><a href="decision_makers/finite_state_machine/implementation.html"><strong aria-hidden="true">3.1.2.</strong> How to implement</a></li><li class="chapter-item expanded "><a href="decision_makers/finite_state_machine/use_of_machinery.html"><strong aria-hidden="true">3.1.3.</strong> Use of Machinery decision maker from emergent crate</a></li><li class="chapter-item expanded "><a href="decision_makers/finite_state_machine/usecases.html"><strong aria-hidden="true">3.1.4.</strong> Typical use cases</a></li></ol></li><li class="chapter-item expanded "><a href="decision_makers/hierarchical_finite_state_machine/introduction.html"><strong aria-hidden="true">3.2.</strong> Hierarchical Finite State Machine</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="decision_makers/hierarchical_finite_state_machine/explanation.html"><strong aria-hidden="true">3.2.1.</strong> How it works</a></li><li class="chapter-item expanded "><a href="decision_makers/hierarchical_finite_state_machine/implementation.html"><strong aria-hidden="true">3.2.2.</strong> How to implement</a></li><li class="chapter-item expanded "><a href="decision_makers/hierarchical_finite_state_machine/use_of_machinery.html"><strong aria-hidden="true">3.2.3.</strong> Hierarchical use of Machinery decision maker from emergent crate</a></li><li class="chapter-item expanded "><a href="decision_makers/hierarchical_finite_state_machine/usecases.html"><strong aria-hidden="true">3.2.4.</strong> Typical use cases</a></li></ol></li><li class="chapter-item expanded "><a href="decision_makers/utility_ai/introduction.html"><strong aria-hidden="true">3.3.</strong> Utility AI</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="decision_makers/utility_ai/explanation.html"><strong aria-hidden="true">3.3.1.</strong> How it works</a></li><li class="chapter-item expanded "><a href="decision_makers/utility_ai/implementation.html"><strong aria-hidden="true">3.3.2.</strong> How to implement</a></li><li class="chapter-item expanded "><a href="decision_makers/utility_ai/use_of_reasoner.html"><strong aria-hidden="true">3.3.3.</strong> Use of Reasoner decision maker from emergent crate</a></li><li class="chapter-item expanded "><a href="decision_makers/utility_ai/usecases.html"><strong aria-hidden="true">3.3.4.</strong> Typical use cases</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.4.</strong> Behavior Tree</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.5.</strong> Goal Oriented Action Planning</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Emergent gameplay</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">4.1.</strong> Emergent AI agents behavior</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.2.</strong> Emergent storytelling with AI-driven game events</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.3.</strong> Dreams and long-term memories impacting agent behavior</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Integrating AI systems into ECS frameworks</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Common AI problems and solutions</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.1.</strong> NPC day cycle</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.2.</strong> Steering</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.3.</strong> Crowd movement</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.4.</strong> Crowds shared behavior</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Let's create emergent gameplay together!</div></li><li class="chapter-item expanded "><a href="more.html"><strong aria-hidden="true">8.</strong> More...</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Emergent AI - Smart agents and events for games</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>The goal of this book is to introduce readers to wonders of game AI development,
explaining how certain AI techniques work, which of them are best suited for what
usecases and more than everything: to show that AI for games only sounds
intimidating and in reality we all have born with intuition on how to build AI
systems for games.</p>
<p>Although we will cover many AI techniques used in industry, we will be focusing
mostly on ones that lead to producing emergent gameplay, a branch of games AI
that is getting more and more popular.</p>
<p>Also note that while this book is gonna explain AI techniques for games, all
examples and demos will be written in Rust programming language, and sometimes
they will be using <a href="https://github.com/PsichiX/emergent"><strong>emergent</strong></a> crate.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="first-steps"><a class="header" href="#first-steps">First steps</a></h1>
<h2 id="first-of-all-what-do-we-mean-by-the-term-ai"><a class="header" href="#first-of-all-what-do-we-mean-by-the-term-ai">First of all: what do we mean by the term AI?</a></h2>
<p>When we talk about AI for games, we are in fact talking about all decision making
units of logic.</p>
<p>It's improtant to understand that decision making, or AI, isn't suited only for
agents in the game - it can be and already is widely used for animation systems,
events happening in game world, or even to control sounds and music.</p>
<h2 id="you-are-probably-already-making-an-ai-system-without-even-noticing-it-right-now"><a class="header" href="#you-are-probably-already-making-an-ai-system-without-even-noticing-it-right-now">You are probably already making an AI system without even noticing it right now!</a></h2>
<p>For a moment let's try to write a simple enemy wandering code the way we usually do.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Direction {
  Up,
  Down,
  Left,
  Right,
}

impl Direction {
  fn horizontal(&amp;self) -&gt; isize {
    match self {
      Self::Left =&gt; -1,
      Self::Right =&gt; 1,
      _ =&gt; 0,
    }
  }

  fn vertical(&amp;self) -&gt; isize {
    match self {
      Self::Up =&gt; -1,
      Self::Down =&gt; 1,
      _ =&gt; 0,
    }
  }

  fn next(&amp;self) -&gt; Self {
    match self {
      Self::Up =&gt; Self::Right,
      Self::Down =&gt; Self::Left,
      Self::Left =&gt; Self::Up,
      Self::Right =&gt; Self::Down,
    }
  }
}

struct Enemy {
  position: (isize, isize),
  direction: Direction,
  change_direction_turns: usize,
  wait_turns: usize,
}

impl Enemy {
  fn new(x: isize, y: isize) -&gt; Self {
    Self {
      position: (x, y),
      direction: Direction::Up,
      change_direction_turns: 0,
      wait_turns: 0,
    }
  }

  fn update(&amp;mut self) {
    if self.wait_turns &gt; 0 {
      self.wait_turns -= 1;
    } else if self.change_direction_turns &gt; 0 {
      self.change_direction_turns -= 1;
      self.position.0 += self.direction.horizontal();
      self.position.1 += self.direction.vertical();
    } else {
      self.direction = self.direction.next();
      self.change_direction_turns = 4;
      self.wait_turns = 2;
    }
  }
}
<span class="boring">}</span></code></pre></pre>
<p>You can notice <code>update</code> function - this is what controls this enemy simple AI.
You might not have noticed it but you have used Finite State Machine for this
problem, hardcore way thought.</p>
<p>Btw. That snippet was really hard to read, right? Yeah, that's how our naive
&quot;simple&quot; AI implementations usually end up growing in complexity.</p>
<p>We can do better, let me refactor it to prove it to you:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">enum Direction {
</span><span class="boring">  Up,
</span><span class="boring">  Down,
</span><span class="boring">  Left,
</span><span class="boring">  Right,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Direction {
</span><span class="boring">  fn horizontal(&amp;self) -&gt; isize {
</span><span class="boring">    match self {
</span><span class="boring">      Self::Left =&gt; -1,
</span><span class="boring">      Self::Right =&gt; 1,
</span><span class="boring">      _ =&gt; 0,
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn vertical(&amp;self) -&gt; isize {
</span><span class="boring">    match self {
</span><span class="boring">      Self::Up =&gt; -1,
</span><span class="boring">      Self::Down =&gt; 1,
</span><span class="boring">      _ =&gt; 0,
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn next(&amp;self) -&gt; Self {
</span><span class="boring">    match self {
</span><span class="boring">      Self::Up =&gt; Self::Right,
</span><span class="boring">      Self::Down =&gt; Self::Left,
</span><span class="boring">      Self::Left =&gt; Self::Up,
</span><span class="boring">      Self::Right =&gt; Self::Down,
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span>enum State {
  Wait(usize),
  ChangeDirection,
  Move(usize),
}

struct Enemy {
  position: (isize, isize),
  direction: Direction,
  state: State,
}

impl Enemy {
  fn new(x: isize, y: isize) -&gt; Self {
    Self {
      position: (x, y),
      direction: Direction::Up,
      state: State::ChangeDirection,
    }
  }

  fn update(&amp;mut self) {
    match &amp;mut self.state {
      State::Wait(turns) =&gt; {
        if *turns &gt; 0 {
          *turns -= 1;
        } else {
          self.state = State::ChangeDirection;
        }
      },
      State::ChangeDirection =&gt; {
        self.direction = self.direction.next();
        self.state = State::Move(4);
      },
      State::Move(turns) =&gt; {
        if *turns &gt; 0 {
          *turns -= 1;
          self.position.0 += self.direction.horizontal();
          self.position.1 += self.direction.vertical();
        } else {
          self.state = State::Wait(2);
        }
      },
    }
  }
}
<span class="boring">}</span></code></pre></pre>
<p>Now we can clearly see what is the actual behavior of this AI:</p>
<ul>
<li>wait few turns</li>
<li>change direction</li>
<li>move forward for few turns</li>
</ul>
<p>And we have got rid of a bug where our previous magic didn't actually do what we
aimed for the way we wanted it to do. This is the simplest state machine we have
learned to make, most likely at this point you're already making them this way.</p>
<p>Now imagine we get more states to handle, like shooting, taking cover when on
low health, finding ammo when it ends - number of state changes and branching
grows exponentially with number of states and our code starts to look more like
a spaghetti than code with clear and easily understandable intent. Have you
encountered that frustration yet?</p>
<p>This is the exact reason why AI systems have been invented in first place - to
simplify readability of and iteration over AI logic.</p>
<p>In next chapters we will learn about AI systems and gradually work our way out
from naive AI logic to more managable solutions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="decision-makers"><a class="header" href="#decision-makers">Decision makers</a></h1>
<p>In <a href="decision_makers/../first_steps.html">previous chapter</a> we have seen use of the <strong>FSM</strong> (Finite State Machines).
FSM is just one of many AI engines called decision makers (a.k.a. AI systems).</p>
<p>Decision makers only job is to do what their name suggest - make a decision about
what agent should do. They usually contain a set of states/actions with rules to
possible transitions, what differentiate one from another is how these transitions
are resolved.</p>
<p>In next chapters we will take a look at decision makers used in the industry and
explain how they work, what are their pros and cons and what to use them for.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="finite-state-machine"><a class="header" href="#finite-state-machine">Finite State Machine</a></h1>
<p>When starting the journey with AI systems, Finite State Machines (FSM in short
from now on) are always the first choice for AI system for a reason - they are
the simplest to implement and the most intuitive decision making engines ever
invented.</p>
<p>Here, take a look at the states and transitions of our simple enemy behavior:</p>
<p><img src="decision_makers/finite_state_machine/../../images/fsm.svg" alt="FSM" /></p>
<p>Each block is a state that enemy can be in and every arrow is a transition with
condition that has to be met to allow for transition to happen.
Here in our case there are simple, single transitions pointing from one state to
another, but in more complex behaviors there can be <em>infinite</em> number of
transitions.</p>
<p>Decision making for FSM has a really simple rule applied to it:</p>
<blockquote>
<p>When decision about state change has to be made, FSM goes through all transitions
that starts from active state and validates their conditions, first one that
succeeds triggers change from active state to one that transition points to.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-it-works"><a class="header" href="#how-it-works">How it works</a></h1>
<p>Imagine we start from <strong>Change Direction</strong> state and we tell FSM to make a
decision, it looks at transitions pointing from this state, here there is only
one: <strong>Move</strong> wit condition: <strong>Just Do It</strong> (which here it means: it always
succeeds). Since this tansition condition succeeded, FMS changes its active state
to <strong>Move</strong> state and enemy moves forward for few turns in the direction previously
set by <strong>Change Direction</strong> state.</p>
<p>In the mean time we run decision making from time to time (can be each frame,
can be each second - usually decision making runs at slower frequency than game
frames, or sometimes it is triggered only when decision making engine receives
an event that tells that important change in game state happened and FSM should
make a decision about its new state).</p>
<p>At some point when FSM runs its decision making, goes through <strong>Move</strong> state
transitions and finds out that condition of a transition pointing to <strong>Wait</strong>
state reports no more move turns, so FSM changes its active state to <strong>Wait</strong>
which will wait few turns doing nothing.</p>
<p>When there is no more waiting turns left, FSM switches back to <strong>Change Direction</strong>
state, which all of it makes &quot;Change Direction, Move, Wait&quot; behavior of our Enemy.
Really simple, right?</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-implement"><a class="header" href="#how-to-implement">How to implement</a></h1>
<p>In chapter <a href="decision_makers/finite_state_machine/../../first_steps.html">First steps</a> we have shown the easiest FSM implementation using enums
but the downside of that approach is that when number of states gets bigger, and
number of possible state changes grow with them, we will eventually end up with
spaghetti of state changes put all over the place with no clear way to see all
the states and their transitions in one place. That slows down understanding of
states and relations between them, but we can simplify that even further by
making an easy, modular FSM engine.</p>
<p>I'll show you two ways that FSM are implemented: dummy way and better way.</p>
<h3 id="the-dummy-way"><a class="header" href="#the-dummy-way">The dummy way</a></h3>
<p>Dummy way of implementing FSM works like this: There is a <code>State</code> trait that will
be implemented for all states. This state has <code>update</code> method with context to
read from / write to and it returns optional state ID. We do this bc we want
states to do their work and that state might tells FSM to change into new state
after FSM updates this state.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::{collections::HashMap, hash::Hash};
</span><span class="boring">
</span>trait State&lt;K, T&gt; {
  // FSM runs this method only on curently active state, and after the update it
  // tries to change active state to whatever state ID we return here (None means
  // no change expected).
  fn update(&amp;mut self, context: &amp;mut T) -&gt; Option&lt;K&gt;;
}

struct FSM&lt;K, T&gt; {
  states: HashMap&lt;K, Box&lt;dyn State&lt;K, T&gt;&gt;&gt;,
  active_state: K,
}

impl&lt;K: Hash + Eq, T&gt; FSM&lt;K, T&gt; {
  fn new(active_state: K) -&gt; Self {
    Self {
      states: Default::default(),
      active_state,
    }
  }

  fn state&lt;S: State&lt;K, T&gt; + 'static&gt;(mut self, id: K, state: S) -&gt; Self {
    self.states.insert(id, Box::new(state));
    self
  }

  fn set_active_state(&amp;mut self, id: K) {
    if self.states.contains_key(&amp;id) {
      self.active_state = id;
    }
  }

  fn update(&amp;mut self, context: &amp;mut T) {
    if let Some(state) = self.states.get_mut(&amp;self.active_state) {
      if let Some(id) = state.update(context) {
        self.set_active_state(id);
      }
    }
  }
}
<span class="boring">}</span></code></pre></pre>
<p>This might looks like the solution used in <a href="decision_makers/finite_state_machine/../../first_steps.html">First steps</a> but with extra steps in
form of states as trait objects. Yes, you're right, so what's the goal of that?
The goal is that with this approach we are able to &quot;easly&quot; iterate on states,
quickly add new ones or remove ones we do not need anymore and all that FSM setup
stay in one place and we have <em>almost completely</em> decoupled states one from
another. Why did i said &quot;almost completely decoupled&quot;? Well, we still have
hardcoded states IDs of transitions in state logic, that's not ok, we will fix
that when we will do <em>the better way</em> of implementing FSM later, for now let's
see how do we use FSM system we have created.</p>
<p>Let's start with implementing enemy states:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait State&lt;K, T&gt; {
</span><span class="boring">  fn update(&amp;mut self, context: &amp;mut T) -&gt; Option&lt;K&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Direction {
</span><span class="boring">  Up,
</span><span class="boring">  Down,
</span><span class="boring">  Left,
</span><span class="boring">  Right,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Direction {
</span><span class="boring">  fn horizontal(&amp;self) -&gt; isize {
</span><span class="boring">    match self {
</span><span class="boring">      Self::Left =&gt; -1,
</span><span class="boring">      Self::Right =&gt; 1,
</span><span class="boring">      _ =&gt; 0,
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn vertical(&amp;self) -&gt; isize {
</span><span class="boring">    match self {
</span><span class="boring">      Self::Up =&gt; -1,
</span><span class="boring">      Self::Down =&gt; 1,
</span><span class="boring">      _ =&gt; 0,
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn next(&amp;self) -&gt; Self {
</span><span class="boring">    match self {
</span><span class="boring">      Self::Up =&gt; Self::Right,
</span><span class="boring">      Self::Down =&gt; Self::Left,
</span><span class="boring">      Self::Left =&gt; Self::Up,
</span><span class="boring">      Self::Right =&gt; Self::Down,
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span>// This enum will be used as key for states.
#[derive(Hash, PartialEq, Eq)]
enum EnemyState {
  Wait,
  Move,
  ChangeDirection,
}

// And this struct will hold all enemy data used by the states.
// It will be passed to FSM as context.
struct EnemyData {
  position: (isize, isize),
  direction: Direction,
}

// It holds number of waiting turns.
struct EnemyWaitState(pub usize);

impl State&lt;EnemyState, EnemyData&gt; for EnemyWaitState {
  fn update(&amp;mut self, context: &amp;mut EnemyData) -&gt; Option&lt;EnemyState&gt; {
    if self.0 &gt; 0 {
      self.0 -= 1;
      None
    } else {
      Some(EnemyState::ChangeDirection)
    }
  }
}

// It holds number of moving turns.
struct EnemyMoveState(pub usize);

impl State&lt;EnemyState, EnemyData&gt; for EnemyMoveState {
  fn update(&amp;mut self, context: &amp;mut EnemyData) -&gt; Option&lt;EnemyState&gt; {
    if self.0 &gt; 0 {
      self.0 -= 1;
      context.position.0 += context.direction.horizontal();
      context.position.1 += context.direction.vertical();
      None
    } else {
      Some(EnemyState::Wait)
    }
  }
}

struct EnemyChangeDirectionState;

impl State&lt;EnemyState, EnemyData&gt; for EnemyChangeDirectionState {
  fn update(&amp;mut self, context: &amp;mut EnemyData) -&gt; Option&lt;EnemyState&gt; {
    context.direction = context.direction.next();
    Some(EnemyState::Move)
  }
}
<span class="boring">}</span></code></pre></pre>
<p>Although code size has grown comparing to implementation used in <a href="decision_makers/finite_state_machine/../../first_steps.html">First steps</a>,
we have modularized states. That would get useful when for example we would have
many different NPC types using same context type to store their data and by that
we would share same states across multiple AI agent types - we would reduce
duplication of the logic and would allow for quick adding/removing possible
states for certain types of NPCs, sadly we don't show that here.</p>
<p>Now let's take a look at our enemy type setup:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::{collections::HashMap, hash::Hash};
</span><span class="boring">
</span><span class="boring">trait State&lt;K, T&gt; {
</span><span class="boring">  fn update(&amp;mut self, context: &amp;mut T) -&gt; Option&lt;K&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct FSM&lt;K, T&gt; {
</span><span class="boring">  states: HashMap&lt;K, Box&lt;dyn State&lt;K, T&gt;&gt;&gt;,
</span><span class="boring">  active_state: K,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;K: Hash + Eq, T&gt; FSM&lt;K, T&gt; {
</span><span class="boring">  fn new(active_state: K) -&gt; Self {
</span><span class="boring">    Self {
</span><span class="boring">      states: Default::default(),
</span><span class="boring">      active_state,
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn state&lt;S: State&lt;K, T&gt; + 'static&gt;(mut self, id: K, state: S) -&gt; Self {
</span><span class="boring">    self.states.insert(id, Box::new(state));
</span><span class="boring">    self
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn set_active_state(&amp;mut self, id: K) {
</span><span class="boring">    if self.states.contains_key(&amp;id) {
</span><span class="boring">      self.active_state = id;
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn update(&amp;mut self, context: &amp;mut T) {
</span><span class="boring">    if let Some(state) = self.states.get_mut(&amp;self.active_state) {
</span><span class="boring">      if let Some(id) = state.update(context) {
</span><span class="boring">        self.set_active_state(id);
</span><span class="boring">      }
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, PartialEq, Eq)]
</span><span class="boring">enum Direction {
</span><span class="boring">  Up,
</span><span class="boring">  Down,
</span><span class="boring">  Left,
</span><span class="boring">  Right,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Direction {
</span><span class="boring">  fn horizontal(&amp;self) -&gt; isize {
</span><span class="boring">    match self {
</span><span class="boring">      Self::Left =&gt; -1,
</span><span class="boring">      Self::Right =&gt; 1,
</span><span class="boring">      _ =&gt; 0,
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn vertical(&amp;self) -&gt; isize {
</span><span class="boring">    match self {
</span><span class="boring">      Self::Up =&gt; -1,
</span><span class="boring">      Self::Down =&gt; 1,
</span><span class="boring">      _ =&gt; 0,
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn next(&amp;self) -&gt; Self {
</span><span class="boring">    match self {
</span><span class="boring">      Self::Up =&gt; Self::Right,
</span><span class="boring">      Self::Down =&gt; Self::Left,
</span><span class="boring">      Self::Left =&gt; Self::Up,
</span><span class="boring">      Self::Right =&gt; Self::Down,
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Hash, PartialEq, Eq)]
</span><span class="boring">enum EnemyState {
</span><span class="boring">  Wait,
</span><span class="boring">  Move,
</span><span class="boring">  ChangeDirection,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct EnemyData {
</span><span class="boring">  position: (isize, isize),
</span><span class="boring">  direction: Direction,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct EnemyWaitState(pub usize);
</span><span class="boring">
</span><span class="boring">impl State&lt;EnemyState, EnemyData&gt; for EnemyWaitState {
</span><span class="boring">  fn update(&amp;mut self, context: &amp;mut EnemyData) -&gt; Option&lt;EnemyState&gt; {
</span><span class="boring">    if self.0 &gt; 0 {
</span><span class="boring">      self.0 -= 1;
</span><span class="boring">      None
</span><span class="boring">    } else {
</span><span class="boring">      Some(EnemyState::ChangeDirection)
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct EnemyMoveState(pub usize);
</span><span class="boring">
</span><span class="boring">impl State&lt;EnemyState, EnemyData&gt; for EnemyMoveState {
</span><span class="boring">  fn update(&amp;mut self, context: &amp;mut EnemyData) -&gt; Option&lt;EnemyState&gt; {
</span><span class="boring">    if self.0 &gt; 0 {
</span><span class="boring">      self.0 -= 1;
</span><span class="boring">      context.position.0 += context.direction.horizontal();
</span><span class="boring">      context.position.1 += context.direction.vertical();
</span><span class="boring">      None
</span><span class="boring">    } else {
</span><span class="boring">      Some(EnemyState::Wait)
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct EnemyChangeDirectionState;
</span><span class="boring">
</span><span class="boring">impl State&lt;EnemyState, EnemyData&gt; for EnemyChangeDirectionState {
</span><span class="boring">  fn update(&amp;mut self, context: &amp;mut EnemyData) -&gt; Option&lt;EnemyState&gt; {
</span><span class="boring">    context.direction = context.direction.next();
</span><span class="boring">    Some(EnemyState::Move)
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span>// We are using composition of FSM and enemy data to please the borrow checker
// and allow FSM to mutate enemy data on update.
struct Enemy {
  data: EnemyData,
  fsm: FSM&lt;EnemyState, EnemyData&gt;,
}

impl Enemy {
  fn new(x: isize, y: isize, direction: Direction) -&gt; Self {
    let mut data = EnemyData {
      position: (x, y),
      direction,
    };
    let mut fsm = FSM::new(EnemyState::ChangeDirection)
      .state(EnemyState::Wait, EnemyWaitState(1))
      .state(EnemyState::ChangeDirection, EnemyChangeDirectionState)
      .state(EnemyState::Move, EnemyMoveState(2));

    Self { data, fsm }
  }

  fn update(&amp;mut self) {
    self.fsm.update(&amp;mut self.data);
  }
}
<span class="boring">}</span></code></pre></pre>
<p>You can see now that because we have modularized states, whenever we would want
to create new state we create a state object then apply it to whatever FSM engine
we want without digging through all the code to adapt AI agent to use of new
state - we have simplified behavior development and reduced the time needed for
implementing changes to the AI. Modularity is the key to easier development when
complexity of the AI scales up.</p>
<p>And here are tests that show how enemy state changes in time (look how state
changes after every <code>update</code> method call):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::{collections::HashMap, hash::Hash};
</span><span class="boring">
</span><span class="boring">trait State&lt;K, T&gt; {
</span><span class="boring">  fn update(&amp;mut self, context: &amp;mut T) -&gt; Option&lt;K&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct FSM&lt;K, T&gt; {
</span><span class="boring">  states: HashMap&lt;K, Box&lt;dyn State&lt;K, T&gt;&gt;&gt;,
</span><span class="boring">  active_state: K,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;K: Hash + Eq, T&gt; FSM&lt;K, T&gt; {
</span><span class="boring">  fn new(active_state: K) -&gt; Self {
</span><span class="boring">    Self {
</span><span class="boring">      states: Default::default(),
</span><span class="boring">      active_state,
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn state&lt;S: State&lt;K, T&gt; + 'static&gt;(mut self, id: K, state: S) -&gt; Self {
</span><span class="boring">    self.states.insert(id, Box::new(state));
</span><span class="boring">    self
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn set_active_state(&amp;mut self, id: K) {
</span><span class="boring">    if self.states.contains_key(&amp;id) {
</span><span class="boring">      self.active_state = id;
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn update(&amp;mut self, context: &amp;mut T) {
</span><span class="boring">    if let Some(state) = self.states.get_mut(&amp;self.active_state) {
</span><span class="boring">      if let Some(id) = state.update(context) {
</span><span class="boring">        self.set_active_state(id);
</span><span class="boring">      }
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, PartialEq, Eq)]
</span><span class="boring">enum Direction {
</span><span class="boring">  Up,
</span><span class="boring">  Down,
</span><span class="boring">  Left,
</span><span class="boring">  Right,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Direction {
</span><span class="boring">  fn horizontal(&amp;self) -&gt; isize {
</span><span class="boring">    match self {
</span><span class="boring">      Self::Left =&gt; -1,
</span><span class="boring">      Self::Right =&gt; 1,
</span><span class="boring">      _ =&gt; 0,
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn vertical(&amp;self) -&gt; isize {
</span><span class="boring">    match self {
</span><span class="boring">      Self::Up =&gt; -1,
</span><span class="boring">      Self::Down =&gt; 1,
</span><span class="boring">      _ =&gt; 0,
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn next(&amp;self) -&gt; Self {
</span><span class="boring">    match self {
</span><span class="boring">      Self::Up =&gt; Self::Right,
</span><span class="boring">      Self::Down =&gt; Self::Left,
</span><span class="boring">      Self::Left =&gt; Self::Up,
</span><span class="boring">      Self::Right =&gt; Self::Down,
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Hash, PartialEq, Eq)]
</span><span class="boring">enum EnemyState {
</span><span class="boring">  Wait,
</span><span class="boring">  Move,
</span><span class="boring">  ChangeDirection,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct EnemyData {
</span><span class="boring">  position: (isize, isize),
</span><span class="boring">  direction: Direction,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct EnemyWaitState(pub usize);
</span><span class="boring">
</span><span class="boring">impl State&lt;EnemyState, EnemyData&gt; for EnemyWaitState {
</span><span class="boring">  fn update(&amp;mut self, context: &amp;mut EnemyData) -&gt; Option&lt;EnemyState&gt; {
</span><span class="boring">    if self.0 &gt; 0 {
</span><span class="boring">      self.0 -= 1;
</span><span class="boring">      None
</span><span class="boring">    } else {
</span><span class="boring">      Some(EnemyState::ChangeDirection)
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct EnemyMoveState(pub usize);
</span><span class="boring">
</span><span class="boring">impl State&lt;EnemyState, EnemyData&gt; for EnemyMoveState {
</span><span class="boring">  fn update(&amp;mut self, context: &amp;mut EnemyData) -&gt; Option&lt;EnemyState&gt; {
</span><span class="boring">    if self.0 &gt; 0 {
</span><span class="boring">      self.0 -= 1;
</span><span class="boring">      context.position.0 += context.direction.horizontal();
</span><span class="boring">      context.position.1 += context.direction.vertical();
</span><span class="boring">      None
</span><span class="boring">    } else {
</span><span class="boring">      Some(EnemyState::Wait)
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct EnemyChangeDirectionState;
</span><span class="boring">
</span><span class="boring">impl State&lt;EnemyState, EnemyData&gt; for EnemyChangeDirectionState {
</span><span class="boring">  fn update(&amp;mut self, context: &amp;mut EnemyData) -&gt; Option&lt;EnemyState&gt; {
</span><span class="boring">    context.direction = context.direction.next();
</span><span class="boring">    Some(EnemyState::Move)
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Enemy {
</span><span class="boring">  data: EnemyData,
</span><span class="boring">  fsm: FSM&lt;EnemyState, EnemyData&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Enemy {
</span><span class="boring">  fn new(x: isize, y: isize, direction: Direction) -&gt; Self {
</span><span class="boring">    let mut data = EnemyData {
</span><span class="boring">      position: (x, y),
</span><span class="boring">      direction,
</span><span class="boring">    };
</span><span class="boring">    let mut fsm = FSM::new(EnemyState::ChangeDirection)
</span><span class="boring">      .state(EnemyState::Wait, EnemyWaitState(1))
</span><span class="boring">      .state(EnemyState::ChangeDirection, EnemyChangeDirectionState)
</span><span class="boring">      .state(EnemyState::Move, EnemyMoveState(2));
</span><span class="boring">
</span><span class="boring">    Self { data, fsm }
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn update(&amp;mut self) {
</span><span class="boring">    self.fsm.update(&amp;mut self.data);
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span>let mut enemy = Enemy::new(0, 0, Direction::Up);
assert_eq!(enemy.fsm.active_state, EnemyState::ChangeDirection);
assert_eq!(enemy.data.position.0, 0);
assert_eq!(enemy.data.position.1, 0);
assert_eq!(enemy.data.direction, Direction::Up);

for i in 0..3 {
  enemy.update();
  assert_eq!(enemy.fsm.active_state, EnemyState::Move);
  assert_eq!(enemy.data.position.0, i);
  assert_eq!(enemy.data.position.1, 0);
  assert_eq!(enemy.data.direction, Direction::Right);
}
for _ in 0..2 {
  enemy.update();
  assert_eq!(enemy.fsm.active_state, EnemyState::Wait);
  assert_eq!(enemy.data.position.0, 2);
  assert_eq!(enemy.data.position.1, 0);
  assert_eq!(enemy.data.direction, Direction::Right);
}
enemy.update();
assert_eq!(enemy.fsm.active_state, EnemyState::ChangeDirection);
assert_eq!(enemy.data.position.0, 2);
assert_eq!(enemy.data.position.1, 0);
assert_eq!(enemy.data.direction, Direction::Right);
<span class="boring">}</span></code></pre></pre>
<p>Now, do you remember we have been talking about &quot;almost completely decoupled
states&quot;? While the downside of this approach to decision making by returning the
ID of state to change into, we can avoid that and actually completely decouple
states from one another if we implement FSM the better way.</p>
<h3 id="the-better-way"><a class="header" href="#the-better-way">The better way</a></h3>
<p>Our goal is to decouple states from one another completely, to do that we have
to find out how states are coupled right now - let's take a look at some state
logic:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait State&lt;K, T&gt; {
</span><span class="boring">  fn update(&amp;mut self, context: &amp;mut T) -&gt; Option&lt;K&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, PartialEq, Eq)]
</span><span class="boring">enum Direction {
</span><span class="boring">  Up,
</span><span class="boring">  Down,
</span><span class="boring">  Left,
</span><span class="boring">  Right,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Direction {
</span><span class="boring">  fn horizontal(&amp;self) -&gt; isize {
</span><span class="boring">    match self {
</span><span class="boring">      Self::Left =&gt; -1,
</span><span class="boring">      Self::Right =&gt; 1,
</span><span class="boring">      _ =&gt; 0,
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn vertical(&amp;self) -&gt; isize {
</span><span class="boring">    match self {
</span><span class="boring">      Self::Up =&gt; -1,
</span><span class="boring">      Self::Down =&gt; 1,
</span><span class="boring">      _ =&gt; 0,
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn next(&amp;self) -&gt; Self {
</span><span class="boring">    match self {
</span><span class="boring">      Self::Up =&gt; Self::Right,
</span><span class="boring">      Self::Down =&gt; Self::Left,
</span><span class="boring">      Self::Left =&gt; Self::Up,
</span><span class="boring">      Self::Right =&gt; Self::Down,
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Hash, PartialEq, Eq)]
</span><span class="boring">enum EnemyState {
</span><span class="boring">  Wait,
</span><span class="boring">  Move,
</span><span class="boring">  ChangeDirection,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct EnemyData {
</span><span class="boring">  position: (isize, isize),
</span><span class="boring">  direction: Direction,
</span><span class="boring">}
</span><span class="boring">
</span>struct EnemyMoveState(pub usize);

impl State&lt;EnemyState, EnemyData&gt; for EnemyMoveState {
  fn update(&amp;mut self, context: &amp;mut EnemyData) -&gt; Option&lt;EnemyState&gt; {
    if self.0 &gt; 0 {
      self.0 -= 1;
      context.position.0 += context.direction.horizontal();
      context.position.1 += context.direction.vertical();
      None
    } else {
      Some(EnemyState::Wait)
    }
  }
}
<span class="boring">}</span></code></pre></pre>
<p>You can see that state update method contains conditions that tell if we should
change into new state and state logic itself (enemy movement).</p>
<p>What we can do with it is we can abstract conditions and state changes into
separate code units and let states only perform their actual logic on update,
also we add a state method to be called when state gets activated so it can setup
context for that state updates:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Condition&lt;T&gt; = fn(&amp;T) -&gt; bool;

trait State&lt;T&gt; {
  fn activated(&amp;mut self, context: &amp;mut T) {}
  fn update(&amp;mut self, context: &amp;mut T) {}
}
<span class="boring">}</span></code></pre></pre>
<p>Since we did that we also have to introduce new FSM transition and state types.
FSM state will now hold the actual state object and list of all possible
transitions, it will also be able to decide if FSM should change into new state
by testing each transition condition and first one that passes, its state ID gets
returned and FSM will then activate that state:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">type Condition&lt;T&gt; = fn(&amp;T) -&gt; bool;
</span><span class="boring">
</span><span class="boring">trait State&lt;T&gt; {
</span><span class="boring">  fn activated(&amp;mut self, context: &amp;mut T) {}
</span><span class="boring">  fn update(&amp;mut self, context: &amp;mut T) {}
</span><span class="boring">}
</span><span class="boring">
</span>struct FSMTransition&lt;K, T&gt; {
  to: K,
  condition: Condition&lt;T&gt;,
}

struct FSMState&lt;K, T&gt; {
  state: Box&lt;dyn State&lt;T&gt;&gt;,
  transitions: Vec&lt;FSMTransition&lt;K, T&gt;&gt;,
}

impl&lt;K, T&gt; FSMState&lt;K, T&gt; {
  fn new&lt;S: State&lt;T&gt; + 'static&gt;(state: S) -&gt; Self {
    Self {
      state: Box::new(state),
      transitions: vec![],
    }
  }

  fn transition(mut self, to: K, condition: Condition&lt;T&gt;) -&gt; Self {
    self.transitions.push(FSMTransition {to, condition});
    self
  }

  fn decide(&amp;self, context: &amp;T) -&gt; Option&lt;K&gt; where K: Clone {
    for transition in &amp;self.transitions {
      if (transition.condition)(context) {
        return Some(transition.to.clone());
      }
    }
    None
  }
}
<span class="boring">}</span></code></pre></pre>
<p>Now what's left is to adapt FSM to work with new states and transitions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::{collections::HashMap, hash::Hash};
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Copy, Clone, PartialEq, Eq)]
</span><span class="boring">enum Direction {
</span><span class="boring">  Up,
</span><span class="boring">  Down,
</span><span class="boring">  Left,
</span><span class="boring">  Right,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Direction {
</span><span class="boring">  fn horizontal(&amp;self) -&gt; isize {
</span><span class="boring">    match self {
</span><span class="boring">      Self::Left =&gt; -1,
</span><span class="boring">      Self::Right =&gt; 1,
</span><span class="boring">      _ =&gt; 0,
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn vertical(&amp;self) -&gt; isize {
</span><span class="boring">    match self {
</span><span class="boring">      Self::Up =&gt; -1,
</span><span class="boring">      Self::Down =&gt; 1,
</span><span class="boring">      _ =&gt; 0,
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn next(&amp;self) -&gt; Self {
</span><span class="boring">    match self {
</span><span class="boring">      Self::Up =&gt; Self::Right,
</span><span class="boring">      Self::Down =&gt; Self::Left,
</span><span class="boring">      Self::Left =&gt; Self::Up,
</span><span class="boring">      Self::Right =&gt; Self::Down,
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Condition&lt;T&gt; = fn(&amp;T) -&gt; bool;
</span><span class="boring">
</span><span class="boring">trait State&lt;T&gt; {
</span><span class="boring">  fn activated(&amp;mut self, context: &amp;mut T) {}
</span><span class="boring">  fn update(&amp;mut self, context: &amp;mut T) {}
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct FSMTransition&lt;K, T&gt; {
</span><span class="boring">  to: K,
</span><span class="boring">  condition: Condition&lt;T&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct FSMState&lt;K, T&gt; {
</span><span class="boring">  state: Box&lt;dyn State&lt;T&gt;&gt;,
</span><span class="boring">  transitions: Vec&lt;FSMTransition&lt;K, T&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;K, T&gt; FSMState&lt;K, T&gt; {
</span><span class="boring">  fn new&lt;S: State&lt;T&gt; + 'static&gt;(state: S) -&gt; Self {
</span><span class="boring">    Self {
</span><span class="boring">      state: Box::new(state),
</span><span class="boring">      transitions: vec![],
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn transition(mut self, to: K, condition: Condition&lt;T&gt;) -&gt; Self {
</span><span class="boring">    self.transitions.push(FSMTransition {to, condition});
</span><span class="boring">    self
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn decide(&amp;self, context: &amp;T) -&gt; Option&lt;K&gt; where K: Clone {
</span><span class="boring">    for transition in &amp;self.transitions {
</span><span class="boring">      if (transition.condition)(context) {
</span><span class="boring">        return Some(transition.to.clone());
</span><span class="boring">      }
</span><span class="boring">    }
</span><span class="boring">    None
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span>struct FSM&lt;K, T&gt; {
  states: HashMap&lt;K, FSMState&lt;K, T&gt;&gt;,
  active_state: K,
}

impl&lt;K: Hash + Eq, T&gt; FSM&lt;K, T&gt; {
  fn new(active_state: K) -&gt; Self {
    Self {
      states: Default::default(),
      active_state,
    }
  }

  fn state(mut self, id: K, state: FSMState&lt;K, T&gt;) -&gt; Self {
    self.states.insert(id, state);
    self
  }

  fn set_active_state(&amp;mut self, id: K, context: &amp;mut T) {
    if let Some(state) = self.states.get_mut(&amp;id) {
      state.state.activated(context);
      self.active_state = id;
    }
  }

  fn decide(&amp;mut self, context: &amp;mut T) where K: Clone {
    if let Some(state) = self.states.get(&amp;self.active_state) {
      if let Some(id) = state.decide(context) {
        self.set_active_state(id, context);
      }
    }
  }

  fn update(&amp;mut self, context: &amp;mut T) {
    if let Some(state) = self.states.get_mut(&amp;self.active_state) {
      state.state.update(context);
    }
  }
}
<span class="boring">}</span></code></pre></pre>
<p>We have separated previous version of <code>update</code> method into two methods, one for
deciding on what state FSM should change into, and another to actually update
active state.</p>
<p>We could still keep them together but it's good to make methods do only the job
they describe - that will allow user to for example run decision making at lower
frequency than the states update (for the sake of this tutorial we will call
them together in enemy <code>tick</code> method just for the sake of smplification).</p>
<p>When it comes to the enemy code itself, not much have changed except FSM setup
and enemy data type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::{collections::HashMap, hash::Hash};
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Copy, Clone, PartialEq, Eq)]
</span><span class="boring">enum Direction {
</span><span class="boring">  Up,
</span><span class="boring">  Down,
</span><span class="boring">  Left,
</span><span class="boring">  Right,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Direction {
</span><span class="boring">  fn horizontal(&amp;self) -&gt; isize {
</span><span class="boring">    match self {
</span><span class="boring">      Self::Left =&gt; -1,
</span><span class="boring">      Self::Right =&gt; 1,
</span><span class="boring">      _ =&gt; 0,
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn vertical(&amp;self) -&gt; isize {
</span><span class="boring">    match self {
</span><span class="boring">      Self::Up =&gt; -1,
</span><span class="boring">      Self::Down =&gt; 1,
</span><span class="boring">      _ =&gt; 0,
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn next(&amp;self) -&gt; Self {
</span><span class="boring">    match self {
</span><span class="boring">      Self::Up =&gt; Self::Right,
</span><span class="boring">      Self::Down =&gt; Self::Left,
</span><span class="boring">      Self::Left =&gt; Self::Up,
</span><span class="boring">      Self::Right =&gt; Self::Down,
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Condition&lt;T&gt; = fn(&amp;T) -&gt; bool;
</span><span class="boring">
</span><span class="boring">trait State&lt;T&gt; {
</span><span class="boring">  fn activated(&amp;mut self, context: &amp;mut T) {}
</span><span class="boring">  fn update(&amp;mut self, context: &amp;mut T) {}
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct FSMTransition&lt;K, T&gt; {
</span><span class="boring">  to: K,
</span><span class="boring">  condition: Condition&lt;T&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct FSMState&lt;K, T&gt; {
</span><span class="boring">  state: Box&lt;dyn State&lt;T&gt;&gt;,
</span><span class="boring">  transitions: Vec&lt;FSMTransition&lt;K, T&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;K, T&gt; FSMState&lt;K, T&gt; {
</span><span class="boring">  fn new&lt;S: State&lt;T&gt; + 'static&gt;(state: S) -&gt; Self {
</span><span class="boring">    Self {
</span><span class="boring">      state: Box::new(state),
</span><span class="boring">      transitions: vec![],
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn transition(mut self, to: K, condition: Condition&lt;T&gt;) -&gt; Self {
</span><span class="boring">    self.transitions.push(FSMTransition {to, condition});
</span><span class="boring">    self
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn decide(&amp;self, context: &amp;T) -&gt; Option&lt;K&gt; where K: Clone {
</span><span class="boring">    for transition in &amp;self.transitions {
</span><span class="boring">      if (transition.condition)(context) {
</span><span class="boring">        return Some(transition.to.clone());
</span><span class="boring">      }
</span><span class="boring">    }
</span><span class="boring">    None
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct FSM&lt;K, T&gt; {
</span><span class="boring">  states: HashMap&lt;K, FSMState&lt;K, T&gt;&gt;,
</span><span class="boring">  active_state: K,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;K: Hash + Eq, T&gt; FSM&lt;K, T&gt; {
</span><span class="boring">  fn new(active_state: K) -&gt; Self {
</span><span class="boring">    Self {
</span><span class="boring">      states: Default::default(),
</span><span class="boring">      active_state,
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn state(mut self, id: K, state: FSMState&lt;K, T&gt;) -&gt; Self {
</span><span class="boring">    self.states.insert(id, state);
</span><span class="boring">    self
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn set_active_state(&amp;mut self, id: K, context: &amp;mut T) {
</span><span class="boring">    if let Some(state) = self.states.get_mut(&amp;id) {
</span><span class="boring">      state.state.activated(context);
</span><span class="boring">      self.active_state = id;
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn decide(&amp;mut self, context: &amp;mut T) where K: Clone {
</span><span class="boring">    if let Some(state) = self.states.get(&amp;self.active_state) {
</span><span class="boring">      if let Some(id) = state.decide(context) {
</span><span class="boring">        self.set_active_state(id, context);
</span><span class="boring">      }
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn update(&amp;mut self, context: &amp;mut T) {
</span><span class="boring">    if let Some(state) = self.states.get_mut(&amp;self.active_state) {
</span><span class="boring">      state.state.update(context);
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
</span><span class="boring">enum EnemyState {
</span><span class="boring">  Wait,
</span><span class="boring">  Move,
</span><span class="boring">  ChangeDirection,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct EnemyWaitState(pub usize);
</span><span class="boring">
</span><span class="boring">impl State&lt;EnemyData&gt; for EnemyWaitState {}
</span><span class="boring">
</span><span class="boring">struct EnemyMoveState(pub usize);
</span><span class="boring">
</span><span class="boring">impl State&lt;EnemyData&gt; for EnemyMoveState {}
</span><span class="boring">
</span><span class="boring">struct EnemyChangeDirectionState;
</span><span class="boring">
</span><span class="boring">impl State&lt;EnemyData&gt; for EnemyChangeDirectionState {}
</span><span class="boring">
</span>struct EnemyData {
  position: (isize, isize),
  direction: Direction,
  // From not on we will keep track of remainding turns in the enemy data.
  // The reason for that is that all states that performs as long as there are
  // turns left, also you might have noticed that in previous versions of states,
  // as long as first cycle ends, all states doesn't wait for any turn because
  // we have zeroed their turn counters, which wasn't what we aimed for in the
  // first place. Now whenever state gets activated, it will set this counter
  // with value from its definition.
  turns: usize,
}

struct Enemy {
  data: EnemyData,
  fsm: FSM&lt;EnemyState, EnemyData&gt;,
}

impl Enemy {
  fn new(x: isize, y: isize, direction: Direction) -&gt; Self {
    let mut data = EnemyData {
      position: (x, y),
      direction,
      turns: 0,
    };
    let fsm = FSM::new(EnemyState::ChangeDirection)
      .state(
        EnemyState::Wait,
        FSMState::new(EnemyWaitState(1))
          .transition(EnemyState::ChangeDirection, |data| data.turns == 0),
      )
      .state(
        EnemyState::Move,
        FSMState::new(EnemyMoveState(2))
          .transition(EnemyState::Wait, |data| data.turns == 0),
      )
      .state(
        EnemyState::ChangeDirection,
        FSMState::new(EnemyChangeDirectionState)
          .transition(EnemyState::Move, |_| true),
      );

    Self { data, fsm }
  }

  fn tick(&amp;mut self) {
    // For the simplicity we just perform decision making and update at once,
    // but you should be encouraged to call decision making only when it's needed,
    // or at least at lower frequency than update, because most of the times, if
    // not always, state changes are rare.
    self.fsm.decide(&amp;mut self.data);
    self.fsm.update(&amp;mut self.data);
  }
}
<span class="boring">}</span></code></pre></pre>
<p>And now our states are completely decoupled from one another, they only do their
job and don't care about any state transitions, making it super easy to just
setup and modify all states and changes at the time when we create FSM:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::{collections::HashMap, hash::Hash};
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Copy, Clone, PartialEq, Eq)]
</span><span class="boring">enum Direction {
</span><span class="boring">  Up,
</span><span class="boring">  Down,
</span><span class="boring">  Left,
</span><span class="boring">  Right,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Direction {
</span><span class="boring">  fn horizontal(&amp;self) -&gt; isize {
</span><span class="boring">    match self {
</span><span class="boring">      Self::Left =&gt; -1,
</span><span class="boring">      Self::Right =&gt; 1,
</span><span class="boring">      _ =&gt; 0,
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn vertical(&amp;self) -&gt; isize {
</span><span class="boring">    match self {
</span><span class="boring">      Self::Up =&gt; -1,
</span><span class="boring">      Self::Down =&gt; 1,
</span><span class="boring">      _ =&gt; 0,
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn next(&amp;self) -&gt; Self {
</span><span class="boring">    match self {
</span><span class="boring">      Self::Up =&gt; Self::Right,
</span><span class="boring">      Self::Down =&gt; Self::Left,
</span><span class="boring">      Self::Left =&gt; Self::Up,
</span><span class="boring">      Self::Right =&gt; Self::Down,
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Condition&lt;T&gt; = fn(&amp;T) -&gt; bool;
</span><span class="boring">
</span><span class="boring">trait State&lt;T&gt; {
</span><span class="boring">  fn activated(&amp;mut self, context: &amp;mut T) {}
</span><span class="boring">  fn update(&amp;mut self, context: &amp;mut T) {}
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct FSMTransition&lt;K, T&gt; {
</span><span class="boring">  to: K,
</span><span class="boring">  condition: Condition&lt;T&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct FSMState&lt;K, T&gt; {
</span><span class="boring">  state: Box&lt;dyn State&lt;T&gt;&gt;,
</span><span class="boring">  transitions: Vec&lt;FSMTransition&lt;K, T&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;K, T&gt; FSMState&lt;K, T&gt; {
</span><span class="boring">  fn new&lt;S: State&lt;T&gt; + 'static&gt;(state: S) -&gt; Self {
</span><span class="boring">    Self {
</span><span class="boring">      state: Box::new(state),
</span><span class="boring">      transitions: vec![],
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn transition(mut self, to: K, condition: Condition&lt;T&gt;) -&gt; Self {
</span><span class="boring">    self.transitions.push(FSMTransition {to, condition});
</span><span class="boring">    self
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn decide(&amp;self, context: &amp;T) -&gt; Option&lt;K&gt; where K: Clone {
</span><span class="boring">    for transition in &amp;self.transitions {
</span><span class="boring">      if (transition.condition)(context) {
</span><span class="boring">        return Some(transition.to.clone());
</span><span class="boring">      }
</span><span class="boring">    }
</span><span class="boring">    None
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct FSM&lt;K, T&gt; {
</span><span class="boring">  states: HashMap&lt;K, FSMState&lt;K, T&gt;&gt;,
</span><span class="boring">  active_state: K,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;K: Hash + Eq, T&gt; FSM&lt;K, T&gt; {
</span><span class="boring">  fn new(active_state: K) -&gt; Self {
</span><span class="boring">    Self {
</span><span class="boring">      states: Default::default(),
</span><span class="boring">      active_state,
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn state(mut self, id: K, state: FSMState&lt;K, T&gt;) -&gt; Self {
</span><span class="boring">    self.states.insert(id, state);
</span><span class="boring">    self
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn set_active_state(&amp;mut self, id: K, context: &amp;mut T) {
</span><span class="boring">    if let Some(state) = self.states.get_mut(&amp;id) {
</span><span class="boring">      state.state.activated(context);
</span><span class="boring">      self.active_state = id;
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn decide(&amp;mut self, context: &amp;mut T) where K: Clone {
</span><span class="boring">    if let Some(state) = self.states.get(&amp;self.active_state) {
</span><span class="boring">      if let Some(id) = state.decide(context) {
</span><span class="boring">        self.set_active_state(id, context);
</span><span class="boring">      }
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn update(&amp;mut self, context: &amp;mut T) {
</span><span class="boring">    if let Some(state) = self.states.get_mut(&amp;self.active_state) {
</span><span class="boring">      state.state.update(context);
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
</span><span class="boring">enum EnemyState {
</span><span class="boring">  Wait,
</span><span class="boring">  Move,
</span><span class="boring">  ChangeDirection,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct EnemyData {
</span><span class="boring">  position: (isize, isize),
</span><span class="boring">  direction: Direction,
</span><span class="boring">  turns: usize,
</span><span class="boring">}
</span><span class="boring">
</span>struct EnemyWaitState(pub usize);

impl State&lt;EnemyData&gt; for EnemyWaitState {
  fn activated(&amp;mut self, context: &amp;mut EnemyData) {
    context.turns = self.0;
  }

  fn update(&amp;mut self, context: &amp;mut EnemyData) {
    context.turns = context.turns.max(1) - 1;
  }
}

struct EnemyMoveState(pub usize);

impl State&lt;EnemyData&gt; for EnemyMoveState {
  fn activated(&amp;mut self, context: &amp;mut EnemyData) {
    context.turns = self.0;
  }

  fn update(&amp;mut self, context: &amp;mut EnemyData) {
    if context.turns &gt; 0 {
      context.turns -= 1;
      context.position.0 += context.direction.horizontal();
      context.position.1 += context.direction.vertical();
    }
  }
}

struct EnemyChangeDirectionState;

impl State&lt;EnemyData&gt; for EnemyChangeDirectionState {
  fn activated(&amp;mut self, context: &amp;mut EnemyData) {
    context.direction = context.direction.next();
  }
}
<span class="boring">}</span></code></pre></pre>
<p>What's left is to look at how our new better FSM mutates its enemy data in time:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::{collections::HashMap, hash::Hash};
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Copy, Clone, PartialEq, Eq)]
</span><span class="boring">enum Direction {
</span><span class="boring">  Up,
</span><span class="boring">  Down,
</span><span class="boring">  Left,
</span><span class="boring">  Right,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Direction {
</span><span class="boring">  fn horizontal(&amp;self) -&gt; isize {
</span><span class="boring">    match self {
</span><span class="boring">      Self::Left =&gt; -1,
</span><span class="boring">      Self::Right =&gt; 1,
</span><span class="boring">      _ =&gt; 0,
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn vertical(&amp;self) -&gt; isize {
</span><span class="boring">    match self {
</span><span class="boring">      Self::Up =&gt; -1,
</span><span class="boring">      Self::Down =&gt; 1,
</span><span class="boring">      _ =&gt; 0,
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn next(&amp;self) -&gt; Self {
</span><span class="boring">    match self {
</span><span class="boring">      Self::Up =&gt; Self::Right,
</span><span class="boring">      Self::Down =&gt; Self::Left,
</span><span class="boring">      Self::Left =&gt; Self::Up,
</span><span class="boring">      Self::Right =&gt; Self::Down,
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Condition&lt;T&gt; = fn(&amp;T) -&gt; bool;
</span><span class="boring">
</span><span class="boring">trait State&lt;T&gt; {
</span><span class="boring">  fn activated(&amp;mut self, context: &amp;mut T) {}
</span><span class="boring">  fn update(&amp;mut self, context: &amp;mut T) {}
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct FSMTransition&lt;K, T&gt; {
</span><span class="boring">  to: K,
</span><span class="boring">  condition: Condition&lt;T&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct FSMState&lt;K, T&gt; {
</span><span class="boring">  state: Box&lt;dyn State&lt;T&gt;&gt;,
</span><span class="boring">  transitions: Vec&lt;FSMTransition&lt;K, T&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;K, T&gt; FSMState&lt;K, T&gt; {
</span><span class="boring">  fn new&lt;S: State&lt;T&gt; + 'static&gt;(state: S) -&gt; Self {
</span><span class="boring">    Self {
</span><span class="boring">      state: Box::new(state),
</span><span class="boring">      transitions: vec![],
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn transition(mut self, to: K, condition: Condition&lt;T&gt;) -&gt; Self {
</span><span class="boring">    self.transitions.push(FSMTransition {to, condition});
</span><span class="boring">    self
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn decide(&amp;self, context: &amp;T) -&gt; Option&lt;K&gt; where K: Clone {
</span><span class="boring">    for transition in &amp;self.transitions {
</span><span class="boring">      if (transition.condition)(context) {
</span><span class="boring">        return Some(transition.to.clone());
</span><span class="boring">      }
</span><span class="boring">    }
</span><span class="boring">    None
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct FSM&lt;K, T&gt; {
</span><span class="boring">  states: HashMap&lt;K, FSMState&lt;K, T&gt;&gt;,
</span><span class="boring">  active_state: K,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;K: Hash + Eq, T&gt; FSM&lt;K, T&gt; {
</span><span class="boring">  fn new(active_state: K) -&gt; Self {
</span><span class="boring">    Self {
</span><span class="boring">      states: Default::default(),
</span><span class="boring">      active_state,
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn state(mut self, id: K, state: FSMState&lt;K, T&gt;) -&gt; Self {
</span><span class="boring">    self.states.insert(id, state);
</span><span class="boring">    self
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn set_active_state(&amp;mut self, id: K, context: &amp;mut T) {
</span><span class="boring">    if let Some(state) = self.states.get_mut(&amp;id) {
</span><span class="boring">      state.state.activated(context);
</span><span class="boring">      self.active_state = id;
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn decide(&amp;mut self, context: &amp;mut T) where K: Clone {
</span><span class="boring">    if let Some(state) = self.states.get(&amp;self.active_state) {
</span><span class="boring">      if let Some(id) = state.decide(context) {
</span><span class="boring">        self.set_active_state(id, context);
</span><span class="boring">      }
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn update(&amp;mut self, context: &amp;mut T) {
</span><span class="boring">    if let Some(state) = self.states.get_mut(&amp;self.active_state) {
</span><span class="boring">      state.state.update(context);
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
</span><span class="boring">enum EnemyState {
</span><span class="boring">  Wait,
</span><span class="boring">  Move,
</span><span class="boring">  ChangeDirection,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct EnemyData {
</span><span class="boring">  position: (isize, isize),
</span><span class="boring">  direction: Direction,
</span><span class="boring">  turns: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Enemy {
</span><span class="boring">  data: EnemyData,
</span><span class="boring">  fsm: FSM&lt;EnemyState, EnemyData&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Enemy {
</span><span class="boring">  fn new(x: isize, y: isize, direction: Direction) -&gt; Self {
</span><span class="boring">    let mut data = EnemyData {
</span><span class="boring">      position: (x, y),
</span><span class="boring">      direction,
</span><span class="boring">      turns: 0,
</span><span class="boring">    };
</span><span class="boring">    let fsm = FSM::new(EnemyState::ChangeDirection)
</span><span class="boring">      .state(
</span><span class="boring">        EnemyState::Wait,
</span><span class="boring">        FSMState::new(EnemyWaitState(1))
</span><span class="boring">          .transition(EnemyState::ChangeDirection, |data| data.turns == 0),
</span><span class="boring">      )
</span><span class="boring">      .state(
</span><span class="boring">        EnemyState::Move,
</span><span class="boring">        FSMState::new(EnemyMoveState(2))
</span><span class="boring">          .transition(EnemyState::Wait, |data| data.turns == 0),
</span><span class="boring">      )
</span><span class="boring">      .state(
</span><span class="boring">        EnemyState::ChangeDirection,
</span><span class="boring">        FSMState::new(EnemyChangeDirectionState)
</span><span class="boring">          .transition(EnemyState::Move, |_| true),
</span><span class="boring">      );
</span><span class="boring">
</span><span class="boring">    Self { data, fsm }
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn tick(&amp;mut self) {
</span><span class="boring">    self.fsm.decide(&amp;mut self.data);
</span><span class="boring">    self.fsm.update(&amp;mut self.data);
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct EnemyWaitState(pub usize);
</span><span class="boring">
</span><span class="boring">impl State&lt;EnemyData&gt; for EnemyWaitState {
</span><span class="boring">  fn activated(&amp;mut self, context: &amp;mut EnemyData) {
</span><span class="boring">    context.turns = self.0;
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn update(&amp;mut self, context: &amp;mut EnemyData) {
</span><span class="boring">    context.turns = context.turns.max(1) - 1;
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct EnemyMoveState(pub usize);
</span><span class="boring">
</span><span class="boring">impl State&lt;EnemyData&gt; for EnemyMoveState {
</span><span class="boring">  fn activated(&amp;mut self, context: &amp;mut EnemyData) {
</span><span class="boring">    context.turns = self.0;
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn update(&amp;mut self, context: &amp;mut EnemyData) {
</span><span class="boring">    if context.turns &gt; 0 {
</span><span class="boring">      context.turns -= 1;
</span><span class="boring">      context.position.0 += context.direction.horizontal();
</span><span class="boring">      context.position.1 += context.direction.vertical();
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct EnemyChangeDirectionState;
</span><span class="boring">
</span><span class="boring">impl State&lt;EnemyData&gt; for EnemyChangeDirectionState {
</span><span class="boring">  fn activated(&amp;mut self, context: &amp;mut EnemyData) {
</span><span class="boring">    context.direction = context.direction.next();
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span>let mut enemy = Enemy::new(0, 0, Direction::Up);

enemy.tick();
assert_eq!(enemy.fsm.active_state, EnemyState::Move);
assert_eq!(enemy.data.position.0, 0);
assert_eq!(enemy.data.position.1, -1);
assert_eq!(enemy.data.direction, Direction::Up);
assert_eq!(enemy.data.turns, 1);
enemy.tick();
assert_eq!(enemy.fsm.active_state, EnemyState::Move);
assert_eq!(enemy.data.position.0, 0);
assert_eq!(enemy.data.position.1, -2);
assert_eq!(enemy.data.direction, Direction::Up);
assert_eq!(enemy.data.turns, 0);
enemy.tick();
assert_eq!(enemy.fsm.active_state, EnemyState::Wait);
assert_eq!(enemy.data.position.0, 0);
assert_eq!(enemy.data.position.1, -2);
assert_eq!(enemy.data.direction, Direction::Up);
assert_eq!(enemy.data.turns, 0);
enemy.tick();
assert_eq!(enemy.fsm.active_state, EnemyState::ChangeDirection);
assert_eq!(enemy.data.position.0, 0);
assert_eq!(enemy.data.position.1, -2);
assert_eq!(enemy.data.direction, Direction::Right);
assert_eq!(enemy.data.turns, 0);
<span class="boring">}</span></code></pre></pre>
<p>What we have achieved by making FSM the better way:</p>
<ul>
<li>states are now units that do only their actual work.</li>
<li>we have achieved complete decoupling of states by making FSM fully modular.</li>
<li>if we want to create new state or remove existing one, the only place that we
have to adapt is the FSM setup.</li>
<li>if we want to add new transition or remove existing one, the only place that
we have to adapt is the FSM setup, no state logic itself.</li>
</ul>
<p>All of that modularization has reduced development time and complexity of iterations
over AI behaviors, but it's important to warn you that <strong>FSM main downside is
that usually number of transitions grows exponentially with number of states</strong>
and you should consider using other decision making engines when you find yourself
struggling with states and transitions when your FSM gets big enough.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-of-machinery-decision-maker-from-emergent-crate"><a class="header" href="#use-of-machinery-decision-maker-from-emergent-crate">Use of Machinery decision maker from emergent crate</a></h1>
<p>If you would like to just use existing solution for FSM, consider trying
<a href="https://crates.io/emergent"><code>emergent</code></a> crate and its <a href="https://docs.rs/emergent/latest/emergent/decision_makers/machinery/struct.Machinery.html"><code>Machinery</code></a> decision making engine:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate emergent;
</span><span class="boring">use emergent::prelude::*;
</span><span class="boring">use std::hash::Hash;
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Copy, Clone, PartialEq, Eq)]
</span><span class="boring">enum Direction {
</span><span class="boring">  Up,
</span><span class="boring">  Down,
</span><span class="boring">  Left,
</span><span class="boring">  Right,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Direction {
</span><span class="boring">  fn horizontal(&amp;self) -&gt; isize {
</span><span class="boring">    match self {
</span><span class="boring">      Self::Left =&gt; -1,
</span><span class="boring">      Self::Right =&gt; 1,
</span><span class="boring">      _ =&gt; 0,
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn vertical(&amp;self) -&gt; isize {
</span><span class="boring">    match self {
</span><span class="boring">      Self::Up =&gt; -1,
</span><span class="boring">      Self::Down =&gt; 1,
</span><span class="boring">      _ =&gt; 0,
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn next(&amp;self) -&gt; Self {
</span><span class="boring">    match self {
</span><span class="boring">      Self::Up =&gt; Self::Right,
</span><span class="boring">      Self::Down =&gt; Self::Left,
</span><span class="boring">      Self::Left =&gt; Self::Up,
</span><span class="boring">      Self::Right =&gt; Self::Down,
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
</span><span class="boring">enum EnemyState {
</span><span class="boring">  Wait,
</span><span class="boring">  Move,
</span><span class="boring">  ChangeDirection,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct EnemyData {
</span><span class="boring">  position: (isize, isize),
</span><span class="boring">  direction: Direction,
</span><span class="boring">  turns: usize,
</span><span class="boring">}
</span><span class="boring">
</span>struct WaitTask(pub usize);

// Tasks are units that do the actual work of the state.
impl Task&lt;EnemyData&gt; for WaitTask {
  // While task is locked, FSM won't change to another state even if it can.
  // We lock this task for the time there are turns left.
  fn is_locked(&amp;self, memory: &amp;EnemyData) -&gt; bool {
    memory.turns &gt; 0
  }

  fn on_enter(&amp;mut self, memory: &amp;mut EnemyData) {
    memory.turns = self.0;
  }

  fn on_update(&amp;mut self, memory: &amp;mut EnemyData) {
    memory.turns = memory.turns.max(1) - 1;
  }
}

struct MoveTask(pub usize);

impl Task&lt;EnemyData&gt; for MoveTask {
  fn is_locked(&amp;self, memory: &amp;EnemyData) -&gt; bool {
    memory.turns &gt; 0
  }

  fn on_enter(&amp;mut self, memory: &amp;mut EnemyData) {
    memory.turns = self.0;
  }

  fn on_update(&amp;mut self, memory: &amp;mut EnemyData) {
    if memory.turns &gt; 0 {
      memory.turns -= 1;
      memory.position.0 += memory.direction.horizontal();
      memory.position.1 += memory.direction.vertical();
    }
  }
}

struct ChangeDirectionTask;

impl Task&lt;EnemyData&gt; for ChangeDirectionTask {
  fn on_enter(&amp;mut self, memory: &amp;mut EnemyData) {
    memory.direction = memory.direction.next();
  }
}

struct Enemy {
  data: EnemyData,
  machinery: Machinery&lt;EnemyData, EnemyState&gt;,
}

impl Enemy {
  fn new(x: isize, y: isize, direction: Direction) -&gt; Self {
    let mut data = EnemyData {
      position: (x, y),
      direction,
      turns: 0,
    };
    let mut machinery = MachineryBuilder::default()
      .state(
        EnemyState::Wait,
        MachineryState::task(WaitTask(1))
          // In `emergent` Conditions are traits that are implemented also for
          // booleans, which means we can just use constants as conditions so
          // here we make this transition always passing and the state locking
          // controls how long task will run.
          .change(MachineryChange::new(EnemyState::ChangeDirection, true)),
      )
      .state(
        EnemyState::Move,
        MachineryState::task(MoveTask(2))
          .change(MachineryChange::new(EnemyState::Wait, true)),
      )
      .state(
        EnemyState::ChangeDirection,
        MachineryState::task(ChangeDirectionTask)
          .change(MachineryChange::new(EnemyState::Move, true)),
      )
      .build();
    // Newly created decision makers doesn't have any state activated and since
    // FSM can change its states starting from active state, we need to activate
    // first state by ourself.
    machinery.change_active_state(
      Some(EnemyState::ChangeDirection),
      &amp;mut data,
      true,
    );

    Self { data, machinery }
  }

  fn tick(&amp;mut self) {
    // `process` method performs decision making.
    self.machinery.process(&amp;mut self.data);
    self.machinery.update(&amp;mut self.data);
  }
}

let mut enemy = Enemy::new(0, 0, Direction::Up);

assert_eq!(enemy.machinery.active_state(), Some(&amp;EnemyState::ChangeDirection));
assert_eq!(enemy.data.position.0, 0);
assert_eq!(enemy.data.position.1, 0);
assert_eq!(enemy.data.direction, Direction::Right);
for i in 1..3 {
  enemy.tick();
  assert_eq!(enemy.machinery.active_state(), Some(&amp;EnemyState::Move));
  assert_eq!(enemy.data.position.0, i);
  assert_eq!(enemy.data.position.1, 0);
  assert_eq!(enemy.data.direction, Direction::Right);
}
enemy.tick();
assert_eq!(enemy.machinery.active_state(), Some(&amp;EnemyState::Wait));
assert_eq!(enemy.data.position.0, 2);
assert_eq!(enemy.data.position.1, 0);
assert_eq!(enemy.data.direction, Direction::Right);
enemy.tick();
assert_eq!(enemy.machinery.active_state(), Some(&amp;EnemyState::ChangeDirection));
assert_eq!(enemy.data.position.0, 2);
assert_eq!(enemy.data.position.1, 0);
assert_eq!(enemy.data.direction, Direction::Down);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typical-use-cases"><a class="header" href="#typical-use-cases">Typical use cases</a></h1>
<ul>
<li>
<p><strong>Simple deterministic AI behavior</strong></p>
<p>Indie games with small number of AI agent states, usually platformers or
fast-paced games like shooters or bullet hells - in general games that doesn't
need long-term or strategic planning and they have to make decision fast to
adapt to quickly changed environment.</p>
</li>
<li>
<p><strong>Animations</strong></p>
<p>All modern game engines use FSM to manage animations, transition between them
also contains information about blending between states to not make states snap
from one to another instantly.</p>
</li>
<li>
<p><strong>Game states / game modes</strong></p>
<p>Imagine you have a game session with several states: Overworld, Battle, Shop,
Crafting. You might use FSM to manage changes between these different game modes.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hierarchical-finite-state-machine"><a class="header" href="#hierarchical-finite-state-machine">Hierarchical Finite State Machine</a></h1>
<p>In the chapter about <a href="decision_makers/hierarchical_finite_state_machine/../finite_state_machine/introduction.html">FSM</a> we have been talking about FSM being messy when number
of states grows. The reason for that was that along with number of states, number
of transitions grow exponentially, which at the point of having for example 20
different states, behavior is starting to get messy and unmanagable - for that
exact problem Hierarchical Finite State Machines (<strong>HFSM</strong> for short from now on)
has got invented.</p>
<p>Let's take a look at some more complex FSM than what we have made in <a href="decision_makers/hierarchical_finite_state_machine/../finite_state_machine/introduction.html">FSM</a> chapter:</p>
<p><img src="decision_makers/hierarchical_finite_state_machine/../../images/hfsm-0.svg" alt="HFSM-0" /></p>
<p>Number of transitions got higher and we can see that many transitions targets
same state using same condition.</p>
<p>When we analyze this network we can find that there are two distinct super-states:
<strong>Patrol</strong> and <strong>Combat</strong>:</p>
<p><img src="decision_makers/hierarchical_finite_state_machine/../../images/hfsm-1.svg" alt="HFSM-1" /></p>
<p>And each of these states contains their own network of sub-states:</p>
<p><img src="decision_makers/hierarchical_finite_state_machine/../../images/hfsm-2.svg" alt="HFSM-2" /></p>
<p>And this is hierarchical approach to FSM:</p>
<blockquote>
<p>HFSM has the same rules for transitions as FSM, what's new is that you can use
other FSM networks as states. Whenever FSM network, used as state in another
FSM, gets activated, it will reset its active state to initial one.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-it-works-1"><a class="header" href="#how-it-works-1">How it works</a></h1>
<p>Rememeber that HFSM is just a FSM that can use other FSM objects as states, hence
<em>hierarchy</em> in the name - we compose networks in other networks.</p>
<p>We have a hierarchy of states that looks like this:</p>
<ul>
<li>Patrol
<ul>
<li>Find Next Waypoint</li>
<li>Walk Towards Waypoint</li>
</ul>
</li>
<li>Combat
<ul>
<li>Walk towards player</li>
<li>Attack player</li>
</ul>
</li>
</ul>
<p>Each network layer doesn't know anything about other networks, they are fully
encapsulated. We start at first network layer which has <strong>Patrol</strong> and <strong>Combat</strong>
states and start with <strong>Patrol</strong> state active, it gets activated and we start
executing <strong>Patrol</strong> network which has <strong>Find Next Waypoint</strong> state (we start
here) and <strong>Walk Towards Waypoint</strong> state. We have found waypoint so we switch
to <strong>Walk Towards Waypoint</strong> state. Notice that while we are executing <strong>Patrol</strong>
network we are still executing root network too, which means at any time we can
get player in range condition succeed and we switch at root level to <strong>Combat</strong>
network, then there it starts at <strong>Walk Towards Player</strong>, it reaches the player,
switches to <strong>Attack Player</strong>, makes player dead and root network switches back
to <strong>Patrol</strong> network, its <strong>Find Next Waypoint</strong> gets activated it cycles between
two states of <strong>Patrol</strong> super-state.</p>
<p>The key information is:</p>
<blockquote>
<p>In HFSM, FSM networks are equivalent to states so as long as network is active,
it will process its states, and if we get networks tree many levels deep, all
nodes (FMS networks) that are along the way from the root to the leaf, are
active and they can make decisions.</p>
</blockquote>
<p>This allows us to modularize our previously made FSM even more, making us able
to group states into reusable &quot;categories&quot; instead of copy-paste bits here and
there - think of it as nested prefabs for behaviors.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-implement-1"><a class="header" href="#how-to-implement-1">How to implement</a></h1>
<p>Happily there is not much work to do to turn FSM into HFSM - what we need to do
is to add <code>decide</code> method to <code>State</code> and implement <code>State</code> for <code>FSM</code> type so we
can just use it as states, also adapt existing code to process these networks as
states correctly.</p>
<p>Let's start with <code>State</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait State&lt;T&gt; {
  fn activated(&amp;mut self, context: &amp;mut T) {}
  // This method will be called whenever owning FSM doesn't change its state, so
  // we can use it to handle inner decision making - in case of FSM we call its
  // decision making here.
  fn decide(&amp;mut self, context: &amp;mut T) {}
  fn update(&amp;mut self, context: &amp;mut T) {}
}
<span class="boring">}</span></code></pre></pre>
<p>Then we improve <code>FSM</code> to forward decision making and update calls to its children
networks:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::{collections::HashMap, hash::Hash};
</span><span class="boring">
</span><span class="boring">type Condition&lt;T&gt; = fn(&amp;T) -&gt; bool;
</span><span class="boring">
</span><span class="boring">trait State&lt;T&gt; {
</span><span class="boring">  fn activated(&amp;mut self, context: &amp;mut T) {}
</span><span class="boring">  fn decide(&amp;mut self, context: &amp;mut T) {}
</span><span class="boring">  fn update(&amp;mut self, context: &amp;mut T) {}
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct FSMTransition&lt;K, T&gt; {
</span><span class="boring">  to: K,
</span><span class="boring">  condition: Condition&lt;T&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct FSMState&lt;K, T&gt; {
</span><span class="boring">  state: Box&lt;dyn State&lt;T&gt;&gt;,
</span><span class="boring">  transitions: Vec&lt;FSMTransition&lt;K, T&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;K, T&gt; FSMState&lt;K, T&gt; {
</span><span class="boring">  fn new&lt;S: State&lt;T&gt; + 'static&gt;(state: S) -&gt; Self {
</span><span class="boring">    Self {
</span><span class="boring">      state: Box::new(state),
</span><span class="boring">      transitions: vec![],
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn transition(mut self, to: K, condition: Condition&lt;T&gt;) -&gt; Self {
</span><span class="boring">    self.transitions.push(FSMTransition {to, condition});
</span><span class="boring">    self
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn decide(&amp;self, context: &amp;T) -&gt; Option&lt;K&gt; where K: Clone {
</span><span class="boring">    for transition in &amp;self.transitions {
</span><span class="boring">      if (transition.condition)(context) {
</span><span class="boring">        return Some(transition.to.clone());
</span><span class="boring">      }
</span><span class="boring">    }
</span><span class="boring">    None
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span>struct FSM&lt;K, T&gt; {
  states: HashMap&lt;K, FSMState&lt;K, T&gt;&gt;,
  active_state: K,
  // This one will be used to reset active state when this FSM will get activated.
  initial_state: K,
}

impl&lt;K: Hash + Eq, T&gt; FSM&lt;K, T&gt; {
  fn new(active_state: K) -&gt; Self where K: Clone {
    Self {
      states: Default::default(),
      initial_state: active_state.clone(),
      active_state,
    }
  }

<span class="boring">fn state(mut self, id: K, state: FSMState&lt;K, T&gt;) -&gt; Self {
</span><span class="boring">  self.states.insert(id, state);
</span><span class="boring">  self
</span><span class="boring">}
</span><span class="boring">
</span>  // We have added `forced` argument to be able to force change because from now
  // on state won't be activated if it's the same as currently active state.
  // User would call this method with `forced` set to true after FSM creation to
  // initialize newly created FSM.
  fn set_active_state(&amp;mut self, id: K, context: &amp;mut T, forced: bool) {
    if forced || id != self.active_state {
      if let Some(state) = self.states.get_mut(&amp;id) {
        state.state.activated(context);
        self.active_state = id;
      }
    }
  }

  fn decide(&amp;mut self, context: &amp;mut T) where K: Clone {
    if let Some(state) = self.states.get_mut(&amp;self.active_state) {
      if let Some(id) = state.decide(context) {
        self.set_active_state(id, context, false);
      } else {
        // From now on in case of FSM not having to change its state, we can tell
        // active state to optionally handle its decision making (this is useful
        // for nested FSMs).
        state.state.decide(context);
      }
    }
  }
<span class="boring">
</span><span class="boring">fn update(&amp;mut self, context: &amp;mut T) {
</span><span class="boring">  if let Some(state) = self.states.get_mut(&amp;self.active_state) {
</span><span class="boring">    state.state.update(context);
</span><span class="boring">  }
</span><span class="boring">}
</span>}
<span class="boring">}</span></code></pre></pre>
<p>What's left to do is to setup FSM within enemy type.</p>
<p>First, for the sake of the tutorial, we create a simplified data types that will
describe enemy state:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Copy, Clone, PartialEq, Eq)]
enum Target {
  None,
  Found,
  Reached,
}

struct EnemyData {
  waypoint: Target,
  player: Target,
}
<span class="boring">}</span></code></pre></pre>
<p><code>EnemyData</code> will contain information about its targets: waypoint and player.
<code>Target</code> will describe what we know about the target. In case of waypoint it can
be either Found or Reached since there is always some waypoint in the world.
In case of player None means player is dead, Found means player is in enemy range
and Reached means enemy is in contact range of player and can attack him.</p>
<p>Here are all possible states for all FSM hierarchy levels:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
enum EnemyState {
  Patrol,
  Combat,
  FindWaypoint,
  WalkTowardsWaypoint,
  WalkTowardsPlayer,
  AttackPlayer,
}
<span class="boring">}</span></code></pre></pre>
<p>Patrol and Combat are the root level FSM states and these will contain sub-networks.
FindWaypoint and WalkTowardsWaypoint belongs to Patrol FSM, WalkTowardsPlayer
and AttackPlayer belongs to Combat FSM.</p>
<p>Ok, now let's finally see the enemy FSM setup:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::{collections::HashMap, hash::Hash};
</span><span class="boring">
</span><span class="boring">type Condition&lt;T&gt; = fn(&amp;T) -&gt; bool;
</span><span class="boring">
</span><span class="boring">trait State&lt;T&gt; {
</span><span class="boring">  fn activated(&amp;mut self, context: &amp;mut T) {}
</span><span class="boring">  fn decide(&amp;mut self, context: &amp;mut T) {}
</span><span class="boring">  fn update(&amp;mut self, context: &amp;mut T) {}
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct FSMTransition&lt;K, T&gt; {
</span><span class="boring">  to: K,
</span><span class="boring">  condition: Condition&lt;T&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct FSMState&lt;K, T&gt; {
</span><span class="boring">  state: Box&lt;dyn State&lt;T&gt;&gt;,
</span><span class="boring">  transitions: Vec&lt;FSMTransition&lt;K, T&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;K, T&gt; FSMState&lt;K, T&gt; {
</span><span class="boring">  fn new&lt;S: State&lt;T&gt; + 'static&gt;(state: S) -&gt; Self {
</span><span class="boring">    Self {
</span><span class="boring">      state: Box::new(state),
</span><span class="boring">      transitions: vec![],
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn transition(mut self, to: K, condition: Condition&lt;T&gt;) -&gt; Self {
</span><span class="boring">    self.transitions.push(FSMTransition {to, condition});
</span><span class="boring">    self
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn decide(&amp;self, context: &amp;T) -&gt; Option&lt;K&gt; where K: Clone {
</span><span class="boring">    for transition in &amp;self.transitions {
</span><span class="boring">      if (transition.condition)(context) {
</span><span class="boring">        return Some(transition.to.clone());
</span><span class="boring">      }
</span><span class="boring">    }
</span><span class="boring">    None
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct FSM&lt;K, T&gt; {
</span><span class="boring">  states: HashMap&lt;K, FSMState&lt;K, T&gt;&gt;,
</span><span class="boring">  active_state: K,
</span><span class="boring">  initial_state: K,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;K: Hash + Eq, T&gt; FSM&lt;K, T&gt; {
</span><span class="boring">  fn new(active_state: K) -&gt; Self where K: Clone {
</span><span class="boring">    Self {
</span><span class="boring">      states: Default::default(),
</span><span class="boring">      initial_state: active_state.clone(),
</span><span class="boring">      active_state,
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn state(mut self, id: K, state: FSMState&lt;K, T&gt;) -&gt; Self {
</span><span class="boring">    self.states.insert(id, state);
</span><span class="boring">    self
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn set_active_state(&amp;mut self, id: K, context: &amp;mut T, forced: bool) {
</span><span class="boring">    if forced || id != self.active_state {
</span><span class="boring">      if let Some(state) = self.states.get_mut(&amp;id) {
</span><span class="boring">        state.state.activated(context);
</span><span class="boring">        self.active_state = id;
</span><span class="boring">      }
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn decide(&amp;mut self, context: &amp;mut T) where K: Clone {
</span><span class="boring">    if let Some(state) = self.states.get_mut(&amp;self.active_state) {
</span><span class="boring">      if let Some(id) = state.decide(context) {
</span><span class="boring">        self.set_active_state(id, context, false);
</span><span class="boring">      } else {
</span><span class="boring">        state.state.decide(context);
</span><span class="boring">      }
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn update(&amp;mut self, context: &amp;mut T) {
</span><span class="boring">    if let Some(state) = self.states.get_mut(&amp;self.active_state) {
</span><span class="boring">      state.state.update(context);
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;K: Clone + Hash + Eq, T&gt; State&lt;T&gt; for FSM&lt;K, T&gt; {
</span><span class="boring">  fn activated(&amp;mut self, context: &amp;mut T) {
</span><span class="boring">    self.set_active_state(self.initial_state.clone(), context, true);
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn decide(&amp;mut self, context: &amp;mut T) {
</span><span class="boring">    self.decide(context);
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn update(&amp;mut self, context: &amp;mut T) {
</span><span class="boring">    self.update(context);
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Copy, Clone, PartialEq, Eq)]
</span><span class="boring">enum Target {
</span><span class="boring">  None,
</span><span class="boring">  Found,
</span><span class="boring">  Reached,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
</span><span class="boring">enum EnemyState {
</span><span class="boring">  Patrol,
</span><span class="boring">  Combat,
</span><span class="boring">  FindWaypoint,
</span><span class="boring">  WalkTowardsWaypoint,
</span><span class="boring">  WalkTowardsPlayer,
</span><span class="boring">  AttackPlayer,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct EnemyData {
</span><span class="boring">  waypoint: Target,
</span><span class="boring">  player: Target,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Enemy {
</span><span class="boring">  data: EnemyData,
</span><span class="boring">  fsm: FSM&lt;EnemyState, EnemyData&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Enemy {
  fn new() -&gt; Self {
    let mut data = EnemyData {
      waypoint: Target::None,
      player: Target::None,
    };

    let patrol = FSM::new(EnemyState::FindWaypoint)
      .state(
        EnemyState::FindWaypoint,
        FSMState::new(EnemyFindWaypointState)
          .transition(EnemyState::WalkTowardsWaypoint, waypoint_found),
      )
      .state(
        EnemyState::WalkTowardsWaypoint,
        FSMState::new(EnemyWalkTowardsWaypointState)
          .transition(EnemyState::FindWaypoint, waypoint_reached),
      );

    let combat = FSM::new(EnemyState::WalkTowardsPlayer)
      .state(
        EnemyState::WalkTowardsPlayer,
        FSMState::new(EnemyWalkTowardsPlayerState)
          .transition(EnemyState::AttackPlayer, player_reached),
      )
      .state(
        EnemyState::AttackPlayer,
        FSMState::new(EnemyAttackPlayerState)
          .transition(EnemyState::WalkTowardsPlayer, player_found),
      );

    let mut fsm = FSM::new(EnemyState::Patrol)
      .state(
        EnemyState::Patrol,
        FSMState::new(patrol)
          .transition(EnemyState::Combat, player_found),
      )
      .state(
        EnemyState::Combat,
        FSMState::new(combat)
          .transition(EnemyState::Patrol, player_dead),
      );

    fsm.set_active_state(EnemyState::Patrol, &amp;mut data, true);
    Self { data, fsm }
  }
<span class="boring">
</span><span class="boring">fn tick(&amp;mut self) {
</span><span class="boring">  self.fsm.decide(&amp;mut self.data);
</span><span class="boring">  self.fsm.update(&amp;mut self.data);
</span><span class="boring">}
</span>}
<span class="boring">
</span><span class="boring">fn waypoint_found(data: &amp;EnemyData) -&gt; bool {
</span><span class="boring">  data.waypoint == Target::Found
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn waypoint_reached(data: &amp;EnemyData) -&gt; bool {
</span><span class="boring">  data.waypoint == Target::Reached
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn player_found(data: &amp;EnemyData) -&gt; bool {
</span><span class="boring">  data.player == Target::Found
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn player_reached(data: &amp;EnemyData) -&gt; bool {
</span><span class="boring">  data.player == Target::Reached
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn player_dead(data: &amp;EnemyData) -&gt; bool {
</span><span class="boring">  data.player == Target::None
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct EnemyFindWaypointState;
</span><span class="boring">
</span><span class="boring">impl State&lt;EnemyData&gt; for EnemyFindWaypointState {}
</span><span class="boring">
</span><span class="boring">struct EnemyWalkTowardsWaypointState;
</span><span class="boring">
</span><span class="boring">impl State&lt;EnemyData&gt; for EnemyWalkTowardsWaypointState {}
</span><span class="boring">
</span><span class="boring">struct EnemyWalkTowardsPlayerState;
</span><span class="boring">
</span><span class="boring">impl State&lt;EnemyData&gt; for EnemyWalkTowardsPlayerState {}
</span><span class="boring">
</span><span class="boring">struct EnemyAttackPlayerState;
</span><span class="boring">
</span><span class="boring">impl State&lt;EnemyData&gt; for EnemyAttackPlayerState {}
</span><span class="boring">}</span></code></pre></pre>
<p>All what we had to do was to put patrol and combat FSMs as we put states in root
FSM.</p>
<p>So how all of this setup changes enemy state in time:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::{collections::HashMap, hash::Hash};
</span><span class="boring">
</span><span class="boring">type Condition&lt;T&gt; = fn(&amp;T) -&gt; bool;
</span><span class="boring">
</span><span class="boring">trait State&lt;T&gt; {
</span><span class="boring">  fn activated(&amp;mut self, context: &amp;mut T) {}
</span><span class="boring">  fn decide(&amp;mut self, context: &amp;mut T) {}
</span><span class="boring">  fn update(&amp;mut self, context: &amp;mut T) {}
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct FSMTransition&lt;K, T&gt; {
</span><span class="boring">  to: K,
</span><span class="boring">  condition: Condition&lt;T&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct FSMState&lt;K, T&gt; {
</span><span class="boring">  state: Box&lt;dyn State&lt;T&gt;&gt;,
</span><span class="boring">  transitions: Vec&lt;FSMTransition&lt;K, T&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;K, T&gt; FSMState&lt;K, T&gt; {
</span><span class="boring">  fn new&lt;S: State&lt;T&gt; + 'static&gt;(state: S) -&gt; Self {
</span><span class="boring">    Self {
</span><span class="boring">      state: Box::new(state),
</span><span class="boring">      transitions: vec![],
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn transition(mut self, to: K, condition: Condition&lt;T&gt;) -&gt; Self {
</span><span class="boring">    self.transitions.push(FSMTransition {to, condition});
</span><span class="boring">    self
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn decide(&amp;self, context: &amp;T) -&gt; Option&lt;K&gt; where K: Clone {
</span><span class="boring">    for transition in &amp;self.transitions {
</span><span class="boring">      if (transition.condition)(context) {
</span><span class="boring">        return Some(transition.to.clone());
</span><span class="boring">      }
</span><span class="boring">    }
</span><span class="boring">    None
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct FSM&lt;K, T&gt; {
</span><span class="boring">  states: HashMap&lt;K, FSMState&lt;K, T&gt;&gt;,
</span><span class="boring">  active_state: K,
</span><span class="boring">  initial_state: K,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;K: Hash + Eq, T&gt; FSM&lt;K, T&gt; {
</span><span class="boring">  fn new(active_state: K) -&gt; Self where K: Clone {
</span><span class="boring">    Self {
</span><span class="boring">      states: Default::default(),
</span><span class="boring">      initial_state: active_state.clone(),
</span><span class="boring">      active_state,
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn state(mut self, id: K, state: FSMState&lt;K, T&gt;) -&gt; Self {
</span><span class="boring">    self.states.insert(id, state);
</span><span class="boring">    self
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn set_active_state(&amp;mut self, id: K, context: &amp;mut T, forced: bool) {
</span><span class="boring">    if forced || id != self.active_state {
</span><span class="boring">      if let Some(state) = self.states.get_mut(&amp;id) {
</span><span class="boring">        state.state.activated(context);
</span><span class="boring">        self.active_state = id;
</span><span class="boring">      }
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn decide(&amp;mut self, context: &amp;mut T) where K: Clone {
</span><span class="boring">    if let Some(state) = self.states.get_mut(&amp;self.active_state) {
</span><span class="boring">      if let Some(id) = state.decide(context) {
</span><span class="boring">        self.set_active_state(id, context, false);
</span><span class="boring">      } else {
</span><span class="boring">        state.state.decide(context);
</span><span class="boring">      }
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn update(&amp;mut self, context: &amp;mut T) {
</span><span class="boring">    if let Some(state) = self.states.get_mut(&amp;self.active_state) {
</span><span class="boring">      state.state.update(context);
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;K: Clone + Hash + Eq, T&gt; State&lt;T&gt; for FSM&lt;K, T&gt; {
</span><span class="boring">  fn activated(&amp;mut self, context: &amp;mut T) {
</span><span class="boring">    self.set_active_state(self.initial_state.clone(), context, true);
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn decide(&amp;mut self, context: &amp;mut T) {
</span><span class="boring">    self.decide(context);
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn update(&amp;mut self, context: &amp;mut T) {
</span><span class="boring">    self.update(context);
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Copy, Clone, PartialEq, Eq)]
</span><span class="boring">enum Target {
</span><span class="boring">  None,
</span><span class="boring">  Found,
</span><span class="boring">  Reached,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
</span><span class="boring">enum EnemyState {
</span><span class="boring">  Patrol,
</span><span class="boring">  Combat,
</span><span class="boring">  FindWaypoint,
</span><span class="boring">  WalkTowardsWaypoint,
</span><span class="boring">  WalkTowardsPlayer,
</span><span class="boring">  AttackPlayer,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct EnemyData {
</span><span class="boring">  waypoint: Target,
</span><span class="boring">  player: Target,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Enemy {
</span><span class="boring">  data: EnemyData,
</span><span class="boring">  fsm: FSM&lt;EnemyState, EnemyData&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Enemy {
</span><span class="boring">  fn new() -&gt; Self {
</span><span class="boring">    let mut data = EnemyData {
</span><span class="boring">      waypoint: Target::None,
</span><span class="boring">      player: Target::None,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let patrol = FSM::new(EnemyState::FindWaypoint)
</span><span class="boring">      .state(
</span><span class="boring">        EnemyState::FindWaypoint,
</span><span class="boring">        FSMState::new(EnemyFindWaypointState)
</span><span class="boring">          .transition(EnemyState::WalkTowardsWaypoint, waypoint_found),
</span><span class="boring">      )
</span><span class="boring">      .state(
</span><span class="boring">        EnemyState::WalkTowardsWaypoint,
</span><span class="boring">        FSMState::new(EnemyWalkTowardsWaypointState)
</span><span class="boring">          .transition(EnemyState::FindWaypoint, waypoint_reached),
</span><span class="boring">      );
</span><span class="boring">
</span><span class="boring">    let combat = FSM::new(EnemyState::WalkTowardsPlayer)
</span><span class="boring">      .state(
</span><span class="boring">        EnemyState::WalkTowardsPlayer,
</span><span class="boring">        FSMState::new(EnemyWalkTowardsPlayerState)
</span><span class="boring">          .transition(EnemyState::AttackPlayer, player_reached),
</span><span class="boring">      )
</span><span class="boring">      .state(
</span><span class="boring">        EnemyState::AttackPlayer,
</span><span class="boring">        FSMState::new(EnemyAttackPlayerState)
</span><span class="boring">          .transition(EnemyState::WalkTowardsPlayer, player_found),
</span><span class="boring">      );
</span><span class="boring">
</span><span class="boring">    let mut fsm = FSM::new(EnemyState::Patrol)
</span><span class="boring">      .state(
</span><span class="boring">        EnemyState::Patrol,
</span><span class="boring">        FSMState::new(patrol)
</span><span class="boring">          .transition(EnemyState::Combat, player_found),
</span><span class="boring">      )
</span><span class="boring">      .state(
</span><span class="boring">        EnemyState::Combat,
</span><span class="boring">        FSMState::new(combat)
</span><span class="boring">          .transition(EnemyState::Patrol, player_dead),
</span><span class="boring">      );
</span><span class="boring">
</span><span class="boring">    fsm.set_active_state(EnemyState::Patrol, &amp;mut data, true);
</span><span class="boring">    Self { data, fsm }
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn tick(&amp;mut self) {
</span><span class="boring">    self.fsm.decide(&amp;mut self.data);
</span><span class="boring">    self.fsm.update(&amp;mut self.data);
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn waypoint_found(data: &amp;EnemyData) -&gt; bool {
</span><span class="boring">  data.waypoint == Target::Found
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn waypoint_reached(data: &amp;EnemyData) -&gt; bool {
</span><span class="boring">  data.waypoint == Target::Reached
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn player_found(data: &amp;EnemyData) -&gt; bool {
</span><span class="boring">  data.player == Target::Found
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn player_reached(data: &amp;EnemyData) -&gt; bool {
</span><span class="boring">  data.player == Target::Reached
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn player_dead(data: &amp;EnemyData) -&gt; bool {
</span><span class="boring">  data.player == Target::None
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct EnemyFindWaypointState;
</span><span class="boring">
</span><span class="boring">impl State&lt;EnemyData&gt; for EnemyFindWaypointState {
</span><span class="boring">  fn activated(&amp;mut self, context: &amp;mut EnemyData) {
</span><span class="boring">    context.waypoint = Target::Found;
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct EnemyWalkTowardsWaypointState;
</span><span class="boring">
</span><span class="boring">impl State&lt;EnemyData&gt; for EnemyWalkTowardsWaypointState {
</span><span class="boring">  fn activated(&amp;mut self, context: &amp;mut EnemyData) {
</span><span class="boring">    context.waypoint = Target::Reached;
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct EnemyWalkTowardsPlayerState;
</span><span class="boring">
</span><span class="boring">impl State&lt;EnemyData&gt; for EnemyWalkTowardsPlayerState {
</span><span class="boring">  fn activated(&amp;mut self, context: &amp;mut EnemyData) {
</span><span class="boring">    context.player = Target::Reached;
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct EnemyAttackPlayerState;
</span><span class="boring">
</span><span class="boring">impl State&lt;EnemyData&gt; for EnemyAttackPlayerState {
</span><span class="boring">  fn activated(&amp;mut self, context: &amp;mut EnemyData) {
</span><span class="boring">    context.player = Target::None;
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span>let mut enemy = Enemy::new();
enemy.data.waypoint = Target::Found;

enemy.tick();
assert_eq!(enemy.fsm.active_state, EnemyState::Patrol);
assert_eq!(enemy.data.waypoint, Target::Reached);
assert_eq!(enemy.data.player, Target::None);
enemy.tick();
assert_eq!(enemy.fsm.active_state, EnemyState::Patrol);
assert_eq!(enemy.data.waypoint, Target::Found);
assert_eq!(enemy.data.player, Target::None);

enemy.data.player = Target::Found;

enemy.tick();
assert_eq!(enemy.fsm.active_state, EnemyState::Combat);
assert_eq!(enemy.data.waypoint, Target::Found);
assert_eq!(enemy.data.player, Target::Reached);
enemy.tick();
assert_eq!(enemy.fsm.active_state, EnemyState::Combat);
assert_eq!(enemy.data.waypoint, Target::Found);
assert_eq!(enemy.data.player, Target::None);
enemy.tick();
assert_eq!(enemy.fsm.active_state, EnemyState::Patrol);
assert_eq!(enemy.data.waypoint, Target::Found);
assert_eq!(enemy.data.player, Target::None);
enemy.tick();
assert_eq!(enemy.fsm.active_state, EnemyState::Patrol);
assert_eq!(enemy.data.waypoint, Target::Reached);
assert_eq!(enemy.data.player, Target::None);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hierarchical-use-of-machinery-decision-maker-from-emergent-crate"><a class="header" href="#hierarchical-use-of-machinery-decision-maker-from-emergent-crate">Hierarchical use of Machinery decision maker from emergent crate</a></h1>
<p>By default all <a href="https://crates.io/emergent"><code>emergent</code></a> decision makers are designed to be used in hierarchies
so building HFSM is really simple - you just put one <a href="https://docs.rs/emergent/latest/emergent/decision_makers/machinery/struct.Machinery.html"><code>Machinery</code></a> as a state in
another. What's new comparing to the flat Machinery setup is we have to assign
initial state decision maker that whenever Machinery gets activated, it will
activate some starting state for that Machinery.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate emergent;
</span><span class="boring">use emergent::prelude::*;
</span><span class="boring">use std::hash::Hash;
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Copy, Clone, PartialEq, Eq)]
</span><span class="boring">enum Target {
</span><span class="boring">  None,
</span><span class="boring">  Found,
</span><span class="boring">  Reached,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
</span><span class="boring">enum EnemyState {
</span><span class="boring">  Patrol,
</span><span class="boring">  Combat,
</span><span class="boring">  FindWaypoint,
</span><span class="boring">  WalkTowardsWaypoint,
</span><span class="boring">  WalkTowardsPlayer,
</span><span class="boring">  AttackPlayer,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct EnemyData {
</span><span class="boring">  waypoint: Target,
</span><span class="boring">  player: Target,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Enemy {
</span><span class="boring">  data: EnemyData,
</span><span class="boring">  machinery: Machinery&lt;EnemyData, EnemyState&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Enemy {
  fn new() -&gt; Self {
    let mut data = EnemyData {
      waypoint: Target::None,
      player: Target::None,
    };

    let patrol = MachineryBuilder::default()
      .state(
        EnemyState::FindWaypoint,
        MachineryState::task(EnemyFindWaypointTask)
          .change(MachineryChange::new(
            EnemyState::WalkTowardsWaypoint,
            ClosureCondition::new(waypoint_found),
          )),
      )
      .state(
        EnemyState::WalkTowardsWaypoint,
        MachineryState::task(EnemyWalkTowardsWaypointTask)
          .change(MachineryChange::new(
            EnemyState::FindWaypoint,
            ClosureCondition::new(waypoint_reached),
          )),
      )
      .build()
      // We assign initial state decision maker if we want to make sure that
      // whenever machinery gets activated it will start at some state (useful
      // when building hierarchies, by default machineries start with no active
      // state hence we assign initialization decision maker to automate setting
      // initial state).
      .initial_state_decision_maker(
        SingleDecisionMaker::new(EnemyState::FindWaypoint),
      );

    let combat = MachineryBuilder::default()
      .state(
        EnemyState::WalkTowardsPlayer,
        MachineryState::task(EnemyWalkTowardsPlayerTask)
          .change(MachineryChange::new(
            EnemyState::AttackPlayer,
            ClosureCondition::new(player_reached),
          )),
      )
      .state(
        EnemyState::AttackPlayer,
        MachineryState::task(EnemyAttackPlayerTask)
          .change(MachineryChange::new(
            EnemyState::WalkTowardsPlayer,
            ClosureCondition::new(player_found),
          )),
      )
      .build()
      .initial_state_decision_maker(
        SingleDecisionMaker::new(EnemyState::WalkTowardsPlayer),
      );

    let mut machinery = MachineryBuilder::default()
      .state(
        EnemyState::Patrol,
        MachineryState::task(patrol)
          .change(MachineryChange::new(
            EnemyState::Combat,
            ClosureCondition::new(player_found),
          )),
      )
      .state(
        EnemyState::Combat,
        MachineryState::task(combat)
          .change(MachineryChange::new(
            EnemyState::Patrol,
            ClosureCondition::new(player_dead),
          )),
      )
      .build()
      .initial_state_decision_maker(
        SingleDecisionMaker::new(EnemyState::Patrol),
      );

    // Since we have assigned initial state decision maker we can activate root
    // machinery to activate its initial state.
    machinery.on_enter(&amp;mut data);
    Self { data, machinery }
  }

  fn tick(&amp;mut self) {
    self.machinery.process(&amp;mut self.data);
    self.machinery.update(&amp;mut self.data);
  }
}

// Condition functions that are used in testing possible state changes:

fn waypoint_found(data: &amp;EnemyData) -&gt; bool {
  data.waypoint == Target::Found
}

fn waypoint_reached(data: &amp;EnemyData) -&gt; bool {
  data.waypoint == Target::Reached
}

fn player_found(data: &amp;EnemyData) -&gt; bool {
  data.player == Target::Found
}

fn player_reached(data: &amp;EnemyData) -&gt; bool {
  data.player == Target::Reached
}

fn player_dead(data: &amp;EnemyData) -&gt; bool {
  data.player == Target::None
}

// Enemy state tasks that will process enemy data:

struct EnemyFindWaypointTask;

impl Task&lt;EnemyData&gt; for EnemyFindWaypointTask {
  fn on_enter(&amp;mut self, memory: &amp;mut EnemyData) {
    memory.waypoint = Target::Found;
  }
}

struct EnemyWalkTowardsWaypointTask;

impl Task&lt;EnemyData&gt; for EnemyWalkTowardsWaypointTask {
  fn on_enter(&amp;mut self, memory: &amp;mut EnemyData) {
    memory.waypoint = Target::Reached;
  }
}

struct EnemyWalkTowardsPlayerTask;

impl Task&lt;EnemyData&gt; for EnemyWalkTowardsPlayerTask {
  fn on_enter(&amp;mut self, memory: &amp;mut EnemyData) {
    memory.player = Target::Reached;
  }
}

struct EnemyAttackPlayerTask;

impl Task&lt;EnemyData&gt; for EnemyAttackPlayerTask {
  fn on_enter(&amp;mut self, memory: &amp;mut EnemyData) {
    memory.player = Target::None;
  }
}

let mut enemy = Enemy::new();

enemy.tick();
assert_eq!(enemy.machinery.active_state(), Some(&amp;EnemyState::Patrol));
assert_eq!(enemy.data.waypoint, Target::Reached);
assert_eq!(enemy.data.player, Target::None);
enemy.tick();
assert_eq!(enemy.machinery.active_state(), Some(&amp;EnemyState::Patrol));
assert_eq!(enemy.data.waypoint, Target::Found);
assert_eq!(enemy.data.player, Target::None);

enemy.data.player = Target::Found;

enemy.tick();
assert_eq!(enemy.machinery.active_state(), Some(&amp;EnemyState::Combat));
assert_eq!(enemy.data.waypoint, Target::Found);
assert_eq!(enemy.data.player, Target::Reached);
enemy.tick();
assert_eq!(enemy.machinery.active_state(), Some(&amp;EnemyState::Combat));
assert_eq!(enemy.data.waypoint, Target::Found);
assert_eq!(enemy.data.player, Target::None);
enemy.tick();
assert_eq!(enemy.machinery.active_state(), Some(&amp;EnemyState::Patrol));
assert_eq!(enemy.data.waypoint, Target::Found);
assert_eq!(enemy.data.player, Target::None);
enemy.tick();
assert_eq!(enemy.machinery.active_state(), Some(&amp;EnemyState::Patrol));
assert_eq!(enemy.data.waypoint, Target::Reached);
assert_eq!(enemy.data.player, Target::None);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typical-use-cases-1"><a class="header" href="#typical-use-cases-1">Typical use cases</a></h1>
<p>These are basically the same as <a href="decision_makers/hierarchical_finite_state_machine/../finite_state_machine/usecases.html">FSM use cases</a> but are focused on better
readability and optimizations by using hierarchies of networks instead of one
big flat network.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="utility-ai"><a class="header" href="#utility-ai">Utility AI</a></h1>
<p>In previous chapters we have been talking about FSM and HFSM as a way to build
small, yet easy to manage AI systems. These two and BT (Behavior Trees) have one
benefit that is also their drawback - they have predictable and fixed transitions.</p>
<p>At some point you might have been wondering: &quot;<strong>Is it possible to create an AI
system where transitions between states are rather fluid, and not fixed?</strong>&quot;.
You have been actually starting to question the possibility of emergent gameplay,
where AI behaviors are less predictable and more driven by the changes in the
environment and world itself.</p>
<p>When you aim for emergent behavior of either your AI agents or game events, you
might find yourself struggling with defining these with FSM/HFSM or BT, so let
me introduce you to <strong>Utility AI</strong> system:</p>
<p><img src="decision_makers/utility_ai/../../images/utility.svg" alt="Utility" /></p>
<p>Quick explanation of the terms:</p>
<ul>
<li><strong>State</strong> - We have already explained it with other AI systems.</li>
<li><strong>Consideration</strong> - Scores probability of <em>someting</em> (really vague explanation,
we will explain that more later).</li>
<li><strong>Condition</strong> - Tells if some fact is true.</li>
<li><strong>Score Mapping</strong> - Its job is to map one or more scores into other single score.</li>
</ul>
<p>As you can see, there are no transitions between states, so how all of these units
together decide which state agent should change into?</p>
<blockquote>
<p>Whenever decision has to be made, Utility AI goes through all its states and
scores probability of each state. State with the highest score wins and gets
selected.</p>
</blockquote>
<p>I consider this to be the simplest rule of all AI systems covered in this book.
While transition rule is simple, scoring process might get a little bit tricky.
In the next chapter we will explain how scoring process works.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-it-works-2"><a class="header" href="#how-it-works-2">How it works</a></h1>
<p>Let's take a look again at the infographics from introduction:</p>
<p><img src="decision_makers/utility_ai/../../images/utility.svg" alt="Utility" /></p>
<p>There are three units that are used in scoring process: Score Mapping, Consideration
and sometimes Condition. All of them are called Scorers, because no matter what
input they get, they always return a score.</p>
<blockquote>
<p>It's important to note that although Utility AI doesn't care about the range of
scores at the state level, it is good to keep scores in 0-1 range (percentage)
to make math easier when performing operations on multiple scores (operations
such as sum, or product).</p>
</blockquote>
<h2 id="condition"><a class="header" href="#condition">Condition</a></h2>
<p>We already have used conditions in FSM/HFSM - its role here in Utility AI is to
be mapped to score, true is 100%, false is 0% of probability. When we would use
multiple AI systems in our game, we might want to share some code units so being
able to just map condition into consideration helps a lot.</p>
<h2 id="consideration"><a class="header" href="#consideration">Consideration</a></h2>
<p>Its job is actually pretty much simple: it takes agent context as input and
calculates a probability score out of it.</p>
<p>For example we have &quot;Constant&quot; consideration, which don't care about context and
always returns constant score. There is &quot;Hunger level&quot; consideration, which might
just return a percentage of agent hunger. Thereare also &quot;Proximity&quot; considerations
that might return real distances (for example in meters in world space) mapped
to percentage of given min-max range of acceptable area that objects can be
detected in - the reason for that is that Utility AI doesn't care about the actual
distances, it would rather want a percentage of how close something is so by
clamping real value to some acceptable upper and lower bounds of distance and
turning that into percentage we can easily use it as probability.</p>
<h2 id="score-mapping"><a class="header" href="#score-mapping">Score Mapping</a></h2>
<p>Score mappings are there to map one or more scores to single score.</p>
<p>For example there is &quot;1 - X&quot; score mapping that takes the score of what it wraps
and performs &quot;1 - X&quot; operation on it. Another ones are &quot;X * Y&quot; (product) and
&quot;X + Y&quot; (sum) functions that wraps list of score mappers and calculates
product/sum on them (product and sum score mappings are really useful for
combining groups of scores for two different results - we use product operation
to achieve similar results as when using AND operation on conditions, and we use
sum operation when we aim for OR-like operation).</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>Now to sum things up, let's take a look how we could translate Scorers to functions,
to show that these concepts are in the end just data processing functions that
in the end produce final score of the state:</p>
<ul>
<li>Idle: <code>0.001</code></li>
<li>Gather Food: <code>hunger * (1 - food proximity)</code></li>
<li>Gather Wood: <code>(needs wood ? 1 : 0) * (1 - trees proximity)</code></li>
<li>Attack Opponent: <code>(1 - opponent proximity) + opponent strength</code></li>
</ul>
<p>Now imagine you have a state where</p>
<ul>
<li>hunger: 0.5</li>
<li>distance to food: 0.9 (we assume range of 0-1 meter)</li>
<li>distance to trees: 0.5 (we assume range of 0-1 meter)</li>
<li>wood needed: false</li>
<li>distance to oponent: 1.0 (we assume range of 0-1 meter)</li>
<li>opponent strength: 0.2</li>
</ul>
<p>So we calculate scores for these states:</p>
<ul>
<li>Idle: <code>0.001</code></li>
<li>Gather Food: <code>0.5 * (1 - 0.9)</code> -&gt; <code>0.5 * 0.1</code> -&gt; <code>0.05</code></li>
<li>Gather Wood: <code>0 * (1 - 0.5)</code> -&gt; <code>0 * 0.5</code> -&gt; <code>0</code></li>
<li>Attack Opponent: <code>(1 - 1.0) + 0.2</code> -&gt; <code>0 + 0.2</code> -&gt; <code>0.2</code></li>
</ul>
<p>And the winner is: <strong>Attack Opponent</strong> state!</p>
<blockquote>
<p>You should note that while Utility AI is both easy to setup and develop, it's
hard to debug and make it predictable. Also when defining behaviors that will
use more complex scoring functions, math knowledge might be really helpful to
properly model these behaviors.</p>
</blockquote>
<p>Whenever you find yourself in the need for making fixed transitions for all of
the states, replace Utility AI with other AI systems like FSM/HFSM or Behavior
Trees.</p>
<p>When you would need to have only a part of the states with fixed transitions,
put them in separate AI system and use hierarchy where your Utility AI will
contain for example FSM with fixed transitions (you can do this thanks to
focusing our solutions on full modularity).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-implement-2"><a class="header" href="#how-to-implement-2">How to implement</a></h1>
<p>First we have to define alias types for <code>Score</code> and <code>Scorer</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Score = f32;
type Scorer&lt;T&gt; = fn(&amp;T) -&gt; Score;
<span class="boring">}</span></code></pre></pre>
<p>We aliased <code>f32</code> as <code>Score</code> in case we would want to change it to <code>f64</code> at some
point and be able to perform that change only in alias declaration.</p>
<p><code>Scorer</code> is just an alias to function that will take context as input and produce
score as output, used later as state probability score for decision making.</p>
<p><code>State</code> trait stays the same as what we have made for FSM.</p>
<p>Next we define an <code>UtilityState</code> that will store an actual state and scorer:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::{collections::HashMap, hash::Hash};
</span><span class="boring">
</span><span class="boring">type Score = f32;
</span><span class="boring">type Scorer&lt;T&gt; = fn(&amp;T) -&gt; Score;
</span><span class="boring">
</span><span class="boring">trait State&lt;T&gt; {}
</span><span class="boring">
</span>struct UtilityState&lt;T&gt; {
  state: Box&lt;dyn State&lt;T&gt;&gt;,
  scorer: Scorer&lt;T&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>Now let's implement <code>Utility</code> decision maker:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::{collections::HashMap, hash::Hash};
</span><span class="boring">
</span><span class="boring">type Score = f32;
</span><span class="boring">type Scorer&lt;T&gt; = fn(&amp;T) -&gt; Score;
</span><span class="boring">
</span><span class="boring">trait State&lt;T&gt; {
</span><span class="boring">  fn activated(&amp;mut self, &amp;mut T) {}
</span><span class="boring">  fn decide(&amp;mut self, &amp;mut T) {}
</span><span class="boring">  fn update(&amp;mut self, &amp;mut T) {}
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct UtilityState&lt;T&gt; {
</span><span class="boring">  state: Box&lt;dyn State&lt;T&gt;&gt;,
</span><span class="boring">  scorer: Scorer&lt;T&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>struct Utility&lt;K, T&gt; {
  states: HashMap&lt;K, UtilityState&lt;T&gt;&gt;,
  active_state: K,
}

impl&lt;K: Hash + Eq, T&gt; Utility&lt;K, T&gt; {
  fn new(active_state: K) -&gt; Self {
    Self {
      states: Default::default(),
      active_state,
    }
  }

  fn state&lt;S&gt;(mut self, id: K, state: S, scorer: Scorer&lt;T&gt;) -&gt; Self
  where
    S: State&lt;T&gt; + 'static,
  {
    let state = UtilityState {
      state: Box::new(state),
      scorer,
    };
    self.states.insert(id, state);
    self
  }

  fn set_active_state(&amp;mut self, id: K, context: &amp;mut T, forced: bool) {
    if forced || id != self.active_state {
      if let Some(state) = self.states.get_mut(&amp;id) {
        state.state.activated(context);
        self.active_state = id;
      }
    }
  }

  fn decide(&amp;mut self, context: &amp;mut T) where K: Clone {
    let winner = self
      .states
      .iter()
      .map(|(k, v)| (k, (v.scorer)(context)))
      .max_by(|a, b| a.1.partial_cmp(&amp;b.1).unwrap())
      .map(|(id, _)| id.clone());
    if let Some(id) = winner {
      self.set_active_state(id, context, false);
    }
    if let Some(state) = self.states.get_mut(&amp;self.active_state) {
      state.state.decide(context);
    }
  }

  fn update(&amp;mut self, context: &amp;mut T) {
    if let Some(state) = self.states.get_mut(&amp;self.active_state) {
      state.state.update(context);
    }
  }
}
<span class="boring">}</span></code></pre></pre>
<p>Methods: <code>new</code>, <code>set_active_state</code> and <code>update</code> arent much different from what
we have done for FSM, but <code>decide</code> method changes completely, obviously.</p>
<p>It performs iterator operations suck as:</p>
<ul>
<li>First map each state ID and <code>UtilityState</code> into state ID and state score (by
executing scorer function with the context).</li>
<li>Then it finds an item wth the highest score using <code>max_by</code> iterator operation.</li>
<li>And finally it maps result to get only found state ID.</li>
</ul>
<p>Then if there is winner state ID found, sets active state to one selected (it
will change state only if new one is different than currently active state).</p>
<p>At the end it calls <code>decide</code> method on currently active state, to properly
propagate decision making in case we use <code>Utility</code> in hierarchy just like we did
with HFSM (yes, we are making <code>Utility</code> support hierarchies).</p>
<p>We also need to implement <code>State</code> trait for <code>Utility</code> type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::{collections::HashMap, hash::Hash};
</span><span class="boring">
</span><span class="boring">type Score = f32;
</span><span class="boring">type Scorer&lt;T&gt; = fn(&amp;T) -&gt; Score;
</span><span class="boring">
</span><span class="boring">trait State&lt;T&gt; {
</span><span class="boring">  fn activated(&amp;mut self, &amp;mut T) {}
</span><span class="boring">  fn decide(&amp;mut self, &amp;mut T) {}
</span><span class="boring">  fn update(&amp;mut self, &amp;mut T) {}
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct UtilityState&lt;T&gt; {
</span><span class="boring">  state: Box&lt;dyn State&lt;T&gt;&gt;,
</span><span class="boring">  scorer: Scorer&lt;T&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Utility&lt;K, T&gt; {
</span><span class="boring">  states: HashMap&lt;K, UtilityState&lt;T&gt;&gt;,
</span><span class="boring">  active_state: K,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;K: Hash + Eq, T&gt; Utility&lt;K, T&gt; {
</span><span class="boring">  fn decide(&amp;mut self, context: &amp;mut T) where K: Clone {}
</span><span class="boring">  fn update(&amp;mut self, context: &amp;mut T) {}
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;K: Clone + Hash + Eq, T&gt; State&lt;T&gt; for Utility&lt;K, T&gt; {
  fn decide(&amp;mut self, context: &amp;mut T) {
    self.decide(context);
  }

  fn update(&amp;mut self, context: &amp;mut T) {
    self.update(context);
  }
}
<span class="boring">}</span></code></pre></pre>
<p>Ok, so we have completed <code>Utility</code> decision maker implementation, we can now make
state ID and data types for enemy:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
enum EnemyState {
  Idle,
  GatherFood,
  GatherWood,
  AttackOpponent,
}

struct EnemyData {
  hunger: f32,
  distance_to_food: f32,
  distance_to_trees: f32,
  wood_needed: usize,
  distance_to_opponent: f32,
  opponent_strength: f32,
}
<span class="boring">}</span></code></pre></pre>
<p>We keep these types same as what we have defined in <a href="decision_makers/utility_ai/./explanation.html">explanation chapter</a>.</p>
<p>Now take a look how we can translate scorer operations for these states into
actual scoring functions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">type Score = f32;
</span><span class="boring">
</span><span class="boring">struct EnemyData {
</span><span class="boring">  hunger: f32,
</span><span class="boring">  distance_to_food: f32,
</span><span class="boring">  distance_to_trees: f32,
</span><span class="boring">  wood_needed: usize,
</span><span class="boring">  distance_to_opponent: f32,
</span><span class="boring">  opponent_strength: f32,
</span><span class="boring">}
</span><span class="boring">
</span>fn scorer_idle(context: &amp;EnemyData) -&gt; Score {
  0.001
}

fn scorer_gather_food(context: &amp;EnemyData) -&gt; Score {
  context.hunger * (1.0 - context.distance_to_food)
}

fn scorer_gather_wood(context: &amp;EnemyData) -&gt; Score {
  let wood_needed = if context.wood_needed &gt; 0 { 1.0 } else { 0.0 };
  wood_needed * (1.0 - context.distance_to_trees)
}

fn scorer_attack_opponent(context: &amp;EnemyData) -&gt; Score {
  (1.0 - context.distance_to_opponent) + context.opponent_strength
}
<span class="boring">}</span></code></pre></pre>
<p>Obviously if we would like to reuse parts of these scorers logic we can put these
operations into separate functions, the point is that all what matters is to
produce a single score, you can organize your scorers as you wish.</p>
<p>Next step is to implement enemy states that will mutate enemy data to reflect
changes in the world:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">type Score = f32;
</span><span class="boring">
</span><span class="boring">struct EnemyData {
</span><span class="boring">  hunger: f32,
</span><span class="boring">  distance_to_food: f32,
</span><span class="boring">  distance_to_trees: f32,
</span><span class="boring">  wood_needed: usize,
</span><span class="boring">  distance_to_opponent: f32,
</span><span class="boring">  opponent_strength: f32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait State&lt;T&gt; {
</span><span class="boring">  fn activated(&amp;mut self, &amp;mut T) {}
</span><span class="boring">  fn decide(&amp;mut self, &amp;mut T) {}
</span><span class="boring">  fn update(&amp;mut self, &amp;mut T) {}
</span><span class="boring">}
</span><span class="boring">
</span>struct EnemyIdleState;

impl State&lt;EnemyData&gt; for EnemyIdleState {}

struct EnemyGatherFoodState;

impl State&lt;EnemyData&gt; for EnemyGatherFoodState {
  fn activated(&amp;mut self, context: &amp;mut EnemyData) {
    context.hunger = 0.0;
    context.distance_to_food = 1.0;
  }
}

struct EnemyGatherWoodState;

impl State&lt;EnemyData&gt; for EnemyGatherWoodState {
  fn activated(&amp;mut self, context: &amp;mut EnemyData) {
    context.wood_needed = context.wood_needed.max(1) - 1;
    context.distance_to_trees = 1.0;
  }
}

struct EnemyAttackOpponentState;

impl State&lt;EnemyData&gt; for EnemyAttackOpponentState {
  fn activated(&amp;mut self, context: &amp;mut EnemyData) {
    context.distance_to_opponent = 1.0;
    context.opponent_strength = 0.0;
  }
}
<span class="boring">}</span></code></pre></pre>
<p>Finally we implement <code>Enemy</code> type itself and its <code>Utility</code> decision maker setup:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::{collections::HashMap, hash::Hash};
</span><span class="boring">
</span><span class="boring">type Score = f32;
</span><span class="boring">type Scorer&lt;T&gt; = fn(&amp;T) -&gt; Score;
</span><span class="boring">
</span><span class="boring">trait State&lt;T&gt; {
</span><span class="boring">  fn activated(&amp;mut self, &amp;mut T) {}
</span><span class="boring">  fn decide(&amp;mut self, &amp;mut T) {}
</span><span class="boring">  fn update(&amp;mut self, &amp;mut T) {}
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct UtilityState&lt;T&gt; {
</span><span class="boring">  state: Box&lt;dyn State&lt;T&gt;&gt;,
</span><span class="boring">  scorer: Scorer&lt;T&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Utility&lt;K, T&gt; {
</span><span class="boring">  states: HashMap&lt;K, UtilityState&lt;T&gt;&gt;,
</span><span class="boring">  active_state: K,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;K: Hash + Eq, T&gt; Utility&lt;K, T&gt; {
</span><span class="boring">  fn new(active_state: K) -&gt; Self {
</span><span class="boring">    Self {
</span><span class="boring">      states: Default::default(),
</span><span class="boring">      active_state,
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn state&lt;S&gt;(mut self, id: K, state: S, scorer: Scorer&lt;T&gt;) -&gt; Self
</span><span class="boring">  where
</span><span class="boring">    S: State&lt;T&gt; + 'static,
</span><span class="boring">  {
</span><span class="boring">    let state = UtilityState {
</span><span class="boring">      state: Box::new(state),
</span><span class="boring">      scorer,
</span><span class="boring">    };
</span><span class="boring">    self.states.insert(id, state);
</span><span class="boring">    self
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn set_active_state(&amp;mut self, id: K, context: &amp;mut T, forced: bool) {
</span><span class="boring">    if forced || id != self.active_state {
</span><span class="boring">      if let Some(state) = self.states.get_mut(&amp;id) {
</span><span class="boring">        state.state.activated(context);
</span><span class="boring">        self.active_state = id;
</span><span class="boring">      }
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn decide(&amp;mut self, context: &amp;mut T) where K: Clone {
</span><span class="boring">    let winner = self
</span><span class="boring">      .states
</span><span class="boring">      .iter()
</span><span class="boring">      .map(|(k, v)| (k, (v.scorer)(context)))
</span><span class="boring">      .max_by(|a, b| a.1.partial_cmp(&amp;b.1).unwrap())
</span><span class="boring">      .map(|(id, _)| id.clone());
</span><span class="boring">    if let Some(id) = winner {
</span><span class="boring">      self.set_active_state(id, context, false);
</span><span class="boring">    }
</span><span class="boring">    if let Some(state) = self.states.get_mut(&amp;self.active_state) {
</span><span class="boring">      state.state.decide(context);
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn update(&amp;mut self, context: &amp;mut T) {
</span><span class="boring">    if let Some(state) = self.states.get_mut(&amp;self.active_state) {
</span><span class="boring">      state.state.update(context);
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;K: Clone + Hash + Eq, T&gt; State&lt;T&gt; for Utility&lt;K, T&gt; {
</span><span class="boring">  fn decide(&amp;mut self, context: &amp;mut T) {
</span><span class="boring">    self.decide(context);
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn update(&amp;mut self, context: &amp;mut T) {
</span><span class="boring">    self.update(context);
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
</span><span class="boring">enum EnemyState {
</span><span class="boring">  Idle,
</span><span class="boring">  GatherFood,
</span><span class="boring">  GatherWood,
</span><span class="boring">  AttackOpponent,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct EnemyData {
</span><span class="boring">  hunger: f32,
</span><span class="boring">  distance_to_food: f32,
</span><span class="boring">  distance_to_trees: f32,
</span><span class="boring">  wood_needed: usize,
</span><span class="boring">  distance_to_opponent: f32,
</span><span class="boring">  opponent_strength: f32,
</span><span class="boring">}
</span><span class="boring">
</span>struct Enemy {
  data: EnemyData,
  utility: Utility&lt;EnemyState, EnemyData&gt;,
}

impl Enemy {
  fn new() -&gt; Self {
    let data = EnemyData {
      hunger: 0.0,
      distance_to_food: 1.0,
      distance_to_trees: 1.0,
      wood_needed: 0,
      distance_to_opponent: 1.0,
      opponent_strength: 0.0,
    };
    let utility = Utility::new(EnemyState::Idle)
      .state(EnemyState::Idle, EnemyIdleState, scorer_idle)
      .state(EnemyState::GatherFood, EnemyGatherFoodState, scorer_gather_food)
      .state(EnemyState::GatherWood, EnemyGatherWoodState, scorer_gather_wood)
      .state(
        EnemyState::AttackOpponent,
        EnemyAttackOpponentState,
        scorer_attack_opponent,
      );

    Self { data, utility }
  }

  fn tick(&amp;mut self) {
    self.utility.decide(&amp;mut self.data);
    self.utility.update(&amp;mut self.data);
  }
}
<span class="boring">
</span><span class="boring">fn scorer_idle(context: &amp;EnemyData) -&gt; Score {
</span><span class="boring">  0.001
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn scorer_gather_food(context: &amp;EnemyData) -&gt; Score {
</span><span class="boring">  context.hunger * (1.0 - context.distance_to_food)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn scorer_gather_wood(context: &amp;EnemyData) -&gt; Score {
</span><span class="boring">  let wood_needed = if context.wood_needed &gt; 0 { 1.0 } else { 0.0 };
</span><span class="boring">  wood_needed * (1.0 - context.distance_to_trees)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn scorer_attack_opponent(context: &amp;EnemyData) -&gt; Score {
</span><span class="boring">  (1.0 - context.distance_to_opponent) + context.opponent_strength
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct EnemyIdleState;
</span><span class="boring">
</span><span class="boring">impl State&lt;EnemyData&gt; for EnemyIdleState {}
</span><span class="boring">
</span><span class="boring">struct EnemyGatherFoodState;
</span><span class="boring">
</span><span class="boring">impl State&lt;EnemyData&gt; for EnemyGatherFoodState {
</span><span class="boring">  fn activated(&amp;mut self, context: &amp;mut EnemyData) {
</span><span class="boring">    context.hunger = 0.0;
</span><span class="boring">    context.distance_to_food = 1.0;
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct EnemyGatherWoodState;
</span><span class="boring">
</span><span class="boring">impl State&lt;EnemyData&gt; for EnemyGatherWoodState {
</span><span class="boring">  fn activated(&amp;mut self, context: &amp;mut EnemyData) {
</span><span class="boring">    context.wood_needed = context.wood_needed.max(1) - 1;
</span><span class="boring">    context.distance_to_trees = 1.0;
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct EnemyAttackOpponentState;
</span><span class="boring">
</span><span class="boring">impl State&lt;EnemyData&gt; for EnemyAttackOpponentState {
</span><span class="boring">  fn activated(&amp;mut self, context: &amp;mut EnemyData) {
</span><span class="boring">    context.distance_to_opponent = 1.0;
</span><span class="boring">    context.opponent_strength = 0.0;
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>And what's left is to test how enemy states react to changes in the world:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::{collections::HashMap, hash::Hash};
</span><span class="boring">
</span><span class="boring">type Score = f32;
</span><span class="boring">type Scorer&lt;T&gt; = fn(&amp;T) -&gt; Score;
</span><span class="boring">
</span><span class="boring">trait State&lt;T&gt; {
</span><span class="boring">  fn activated(&amp;mut self, &amp;mut T) {}
</span><span class="boring">  fn decide(&amp;mut self, &amp;mut T) {}
</span><span class="boring">  fn update(&amp;mut self, &amp;mut T) {}
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct UtilityState&lt;T&gt; {
</span><span class="boring">  state: Box&lt;dyn State&lt;T&gt;&gt;,
</span><span class="boring">  scorer: Scorer&lt;T&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Utility&lt;K, T&gt; {
</span><span class="boring">  states: HashMap&lt;K, UtilityState&lt;T&gt;&gt;,
</span><span class="boring">  active_state: K,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;K: Hash + Eq, T&gt; Utility&lt;K, T&gt; {
</span><span class="boring">  fn new(active_state: K) -&gt; Self {
</span><span class="boring">    Self {
</span><span class="boring">      states: Default::default(),
</span><span class="boring">      active_state,
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn state&lt;S&gt;(mut self, id: K, state: S, scorer: Scorer&lt;T&gt;) -&gt; Self
</span><span class="boring">  where
</span><span class="boring">    S: State&lt;T&gt; + 'static,
</span><span class="boring">  {
</span><span class="boring">    let state = UtilityState {
</span><span class="boring">      state: Box::new(state),
</span><span class="boring">      scorer,
</span><span class="boring">    };
</span><span class="boring">    self.states.insert(id, state);
</span><span class="boring">    self
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn set_active_state(&amp;mut self, id: K, context: &amp;mut T, forced: bool) {
</span><span class="boring">    if forced || id != self.active_state {
</span><span class="boring">      if let Some(state) = self.states.get_mut(&amp;id) {
</span><span class="boring">        state.state.activated(context);
</span><span class="boring">        self.active_state = id;
</span><span class="boring">      }
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn decide(&amp;mut self, context: &amp;mut T) where K: Clone {
</span><span class="boring">    let winner = self
</span><span class="boring">      .states
</span><span class="boring">      .iter()
</span><span class="boring">      .map(|(k, v)| (k, (v.scorer)(context)))
</span><span class="boring">      .max_by(|a, b| a.1.partial_cmp(&amp;b.1).unwrap())
</span><span class="boring">      .map(|(id, _)| id.clone());
</span><span class="boring">    if let Some(id) = winner {
</span><span class="boring">      self.set_active_state(id, context, false);
</span><span class="boring">    }
</span><span class="boring">    if let Some(state) = self.states.get_mut(&amp;self.active_state) {
</span><span class="boring">      state.state.decide(context);
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn update(&amp;mut self, context: &amp;mut T) {
</span><span class="boring">    if let Some(state) = self.states.get_mut(&amp;self.active_state) {
</span><span class="boring">      state.state.update(context);
</span><span class="boring">    }
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;K: Clone + Hash + Eq, T&gt; State&lt;T&gt; for Utility&lt;K, T&gt; {
</span><span class="boring">  fn decide(&amp;mut self, context: &amp;mut T) {
</span><span class="boring">    self.decide(context);
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn update(&amp;mut self, context: &amp;mut T) {
</span><span class="boring">    self.update(context);
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
</span><span class="boring">enum EnemyState {
</span><span class="boring">  Idle,
</span><span class="boring">  GatherFood,
</span><span class="boring">  GatherWood,
</span><span class="boring">  AttackOpponent,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct EnemyData {
</span><span class="boring">  hunger: f32,
</span><span class="boring">  distance_to_food: f32,
</span><span class="boring">  distance_to_trees: f32,
</span><span class="boring">  wood_needed: usize,
</span><span class="boring">  distance_to_opponent: f32,
</span><span class="boring">  opponent_strength: f32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Enemy {
</span><span class="boring">  data: EnemyData,
</span><span class="boring">  utility: Utility&lt;EnemyState, EnemyData&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Enemy {
</span><span class="boring">  fn new() -&gt; Self {
</span><span class="boring">    let data = EnemyData {
</span><span class="boring">      hunger: 0.0,
</span><span class="boring">      distance_to_food: 1.0,
</span><span class="boring">      distance_to_trees: 1.0,
</span><span class="boring">      wood_needed: 0,
</span><span class="boring">      distance_to_opponent: 1.0,
</span><span class="boring">      opponent_strength: 0.0,
</span><span class="boring">    };
</span><span class="boring">    let utility = Utility::new(EnemyState::Idle)
</span><span class="boring">      .state(EnemyState::Idle, EnemyIdleState, scorer_idle)
</span><span class="boring">      .state(EnemyState::GatherFood, EnemyGatherFoodState, scorer_gather_food)
</span><span class="boring">      .state(EnemyState::GatherWood, EnemyGatherWoodState, scorer_gather_wood)
</span><span class="boring">      .state(
</span><span class="boring">        EnemyState::AttackOpponent,
</span><span class="boring">        EnemyAttackOpponentState,
</span><span class="boring">        scorer_attack_opponent,
</span><span class="boring">      );
</span><span class="boring">
</span><span class="boring">    Self { data, utility }
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn tick(&amp;mut self) {
</span><span class="boring">    self.utility.decide(&amp;mut self.data);
</span><span class="boring">    self.utility.update(&amp;mut self.data);
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn scorer_idle(context: &amp;EnemyData) -&gt; Score {
</span><span class="boring">  0.001
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn scorer_gather_food(context: &amp;EnemyData) -&gt; Score {
</span><span class="boring">  context.hunger * (1.0 - context.distance_to_food)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn scorer_gather_wood(context: &amp;EnemyData) -&gt; Score {
</span><span class="boring">  let wood_needed = if context.wood_needed &gt; 0 { 1.0 } else { 0.0 };
</span><span class="boring">  wood_needed * (1.0 - context.distance_to_trees)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn scorer_attack_opponent(context: &amp;EnemyData) -&gt; Score {
</span><span class="boring">  (1.0 - context.distance_to_opponent) + context.opponent_strength
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct EnemyIdleState;
</span><span class="boring">
</span><span class="boring">impl State&lt;EnemyData&gt; for EnemyIdleState {}
</span><span class="boring">
</span><span class="boring">struct EnemyGatherFoodState;
</span><span class="boring">
</span><span class="boring">impl State&lt;EnemyData&gt; for EnemyGatherFoodState {
</span><span class="boring">  fn activated(&amp;mut self, context: &amp;mut EnemyData) {
</span><span class="boring">    context.hunger = 0.0;
</span><span class="boring">    context.distance_to_food = 1.0;
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct EnemyGatherWoodState;
</span><span class="boring">
</span><span class="boring">impl State&lt;EnemyData&gt; for EnemyGatherWoodState {
</span><span class="boring">  fn activated(&amp;mut self, context: &amp;mut EnemyData) {
</span><span class="boring">    context.wood_needed = context.wood_needed.max(1) - 1;
</span><span class="boring">    context.distance_to_trees = 1.0;
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct EnemyAttackOpponentState;
</span><span class="boring">
</span><span class="boring">impl State&lt;EnemyData&gt; for EnemyAttackOpponentState {
</span><span class="boring">  fn activated(&amp;mut self, context: &amp;mut EnemyData) {
</span><span class="boring">    context.distance_to_opponent = 1.0;
</span><span class="boring">    context.opponent_strength = 0.0;
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span>let mut enemy = Enemy::new();
assert_eq!(enemy.utility.active_state, EnemyState::Idle);
assert_eq!(enemy.data.hunger, 0.0);
assert_eq!(enemy.data.distance_to_food, 1.0);
assert_eq!(enemy.data.distance_to_trees, 1.0);
assert_eq!(enemy.data.wood_needed, 0);
assert_eq!(enemy.data.distance_to_opponent, 1.0);
assert_eq!(enemy.data.opponent_strength, 0.0);

enemy.data.hunger = 0.5;
enemy.data.distance_to_food = 0.9;
enemy.data.distance_to_trees = 0.5;
enemy.data.opponent_strength = 0.2;

enemy.tick();
assert_eq!(enemy.utility.active_state, EnemyState::AttackOpponent);
assert_eq!(enemy.data.hunger, 0.5);
assert_eq!(enemy.data.distance_to_food, 0.9);
assert_eq!(enemy.data.distance_to_trees, 0.5);
assert_eq!(enemy.data.wood_needed, 0);
assert_eq!(enemy.data.distance_to_opponent, 1.0);
assert_eq!(enemy.data.opponent_strength, 0.0);

enemy.tick();
assert_eq!(enemy.utility.active_state, EnemyState::GatherFood);
assert_eq!(enemy.data.hunger, 0.0);
assert_eq!(enemy.data.distance_to_food, 1.0);
assert_eq!(enemy.data.distance_to_trees, 0.5);
assert_eq!(enemy.data.wood_needed, 0);
assert_eq!(enemy.data.distance_to_opponent, 1.0);
assert_eq!(enemy.data.opponent_strength, 0.0);

enemy.data.wood_needed = 1;

enemy.tick();
assert_eq!(enemy.utility.active_state, EnemyState::GatherWood);
assert_eq!(enemy.data.hunger, 0.0);
assert_eq!(enemy.data.distance_to_food, 1.0);
assert_eq!(enemy.data.distance_to_trees, 1.0);
assert_eq!(enemy.data.wood_needed, 0);
assert_eq!(enemy.data.distance_to_opponent, 1.0);
assert_eq!(enemy.data.opponent_strength, 0.0);

enemy.tick();
assert_eq!(enemy.utility.active_state, EnemyState::Idle);
assert_eq!(enemy.data.hunger, 0.0);
assert_eq!(enemy.data.distance_to_food, 1.0);
assert_eq!(enemy.data.distance_to_trees, 1.0);
assert_eq!(enemy.data.wood_needed, 0);
assert_eq!(enemy.data.distance_to_opponent, 1.0);
assert_eq!(enemy.data.opponent_strength, 0.0);
<span class="boring">}</span></code></pre></pre>
<p>As you can see, all state changes are completely environment-driven - no fixed
transitions, fully emergent behavior.</p>
<p>Not much more is needed to be explained because most implmentation is very similar
if not the same, as with FSM, we just had to implement scoring feature for decision
making - that's how easy is to move from FSM to Utility AI!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-of-reasoner-decision-maker-from-emergent-crate"><a class="header" href="#use-of-reasoner-decision-maker-from-emergent-crate">Use of Reasoner decision maker from emergent crate</a></h1>
<p>Usage of <a href="https://docs.rs/emergent/latest/emergent/decision_makers/reasoner/struct.Reasoner.html"><code>Reasoner</code></a> decision maker from <a href="https://crates.io/emergent"><code>emergent</code></a> crate isn't much different
from what we have made by ourselves - what's different, considerations are actually
separate structs for which we implement <a href="https://docs.rs/emergent/latest/emergent/consideration/trait.Consideration.html"><code>Consideration</code></a> trait but we could also
just use scoring functions and wrap them with <a href="https://docs.rs/emergent/latest/emergent/consideration/struct.ClosureConsideration.html"><code>ClosureConsideration</code></a>, but we
want to keep ourselves on the full modularity track - the point is, there are
many ways you can organize your logic with <a href="https://crates.io/emergent"><code>emergent</code></a> crate, it is all for you
to decide what works best for you.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate emergent;
</span><span class="boring">use emergent::prelude::*;
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
</span><span class="boring">enum EnemyState {
</span><span class="boring">  Idle,
</span><span class="boring">  GatherFood,
</span><span class="boring">  GatherWood,
</span><span class="boring">  AttackOpponent,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct EnemyData {
</span><span class="boring">  hunger: f32,
</span><span class="boring">  distance_to_food: f32,
</span><span class="boring">  distance_to_trees: f32,
</span><span class="boring">  wood_needed: usize,
</span><span class="boring">  distance_to_opponent: f32,
</span><span class="boring">  opponent_strength: f32,
</span><span class="boring">}
</span><span class="boring">
</span>struct Enemy {
  data: EnemyData,
  reasoner: Reasoner&lt;EnemyData, EnemyState&gt;,
}

impl Enemy {
  fn new() -&gt; Self {
    let data = EnemyData {
      hunger: 0.0,
      distance_to_food: 1.0,
      distance_to_trees: 1.0,
      wood_needed: 0,
      distance_to_opponent: 1.0,
      opponent_strength: 0.0,
    };
    let reasoner = ReasonerBuilder::default()
      // Just like with conditions, Consideration trait is implemented to scalars
      // so we can just use constants here.
      // This translates to: `0.001`
      .state(EnemyState::Idle, ReasonerState::new(0.001, EnemyIdleTask))
      .state(EnemyState::GatherFood, ReasonerState::new(
        // Product evaluator will multiply all its children consideration scores.
        // This translates to: `hunger * (1 - food proximity)`
        EvaluatorProduct::default()
          .consideration(Hunger)
          .consideration(ConsiderationRemap::new(
            FoodProximity,
            ReverseScoreMapping,
          )),
        EnemyGatherFoodTask,
      ))
      .state(EnemyState::GatherWood, ReasonerState::new(
        // This translates to: `(wood needed ? 1 : 0) * (1 - trees proximity)`
        EvaluatorProduct::default()
          .consideration(ConditionConsideration::unit(WoodNeeded))
          .consideration(ConsiderationRemap::new(
            TreesProximity,
            ReverseScoreMapping,
          )),
        EnemyGatherWoodTask,
      ))
      .state(EnemyState::AttackOpponent, ReasonerState::new(
        // This translates to: `(1 - opponent proximity) + opponent strength`
        EvaluatorSum::default()
          .consideration(ConsiderationRemap::new(
            OpponentProximity,
            ReverseScoreMapping,
          ))
          .consideration(OpponentStrength),
        EnemyAttackOpponentTask,
      ))
      .build();

    Self { data, reasoner }
  }

  fn tick(&amp;mut self) {
    self.reasoner.process(&amp;mut self.data);
    self.reasoner.update(&amp;mut self.data);
  }
}

// Conditions

struct WoodNeeded;

impl Condition&lt;EnemyData&gt; for WoodNeeded {
  fn validate(&amp;self, memory: &amp;EnemyData) -&gt; bool {
    memory.wood_needed &gt; 0
  }
}

// Considerations

struct Hunger;

impl Consideration&lt;EnemyData&gt; for Hunger {
  fn score(&amp;self, memory: &amp;EnemyData) -&gt; Scalar {
    memory.hunger
  }
}

struct FoodProximity;

impl Consideration&lt;EnemyData&gt; for FoodProximity {
  fn score(&amp;self, memory: &amp;EnemyData) -&gt; Scalar {
    memory.distance_to_food
  }
}

struct TreesProximity;

impl Consideration&lt;EnemyData&gt; for TreesProximity {
  fn score(&amp;self, memory: &amp;EnemyData) -&gt; Scalar {
    memory.distance_to_trees
  }
}

struct OpponentProximity;

impl Consideration&lt;EnemyData&gt; for OpponentProximity {
  fn score(&amp;self, memory: &amp;EnemyData) -&gt; Scalar {
    memory.distance_to_opponent
  }
}

struct OpponentStrength;

impl Consideration&lt;EnemyData&gt; for OpponentStrength {
  fn score(&amp;self, memory: &amp;EnemyData) -&gt; Scalar {
    memory.opponent_strength
  }
}

// Enemy state tasks

struct EnemyIdleTask;

impl Task&lt;EnemyData&gt; for EnemyIdleTask {}

struct EnemyGatherFoodTask;

impl Task&lt;EnemyData&gt; for EnemyGatherFoodTask {
  fn on_enter(&amp;mut self, memory: &amp;mut EnemyData) {
    memory.hunger = 0.0;
    memory.distance_to_food = 1.0;
  }
}

struct EnemyGatherWoodTask;

impl Task&lt;EnemyData&gt; for EnemyGatherWoodTask {
  fn on_enter(&amp;mut self, memory: &amp;mut EnemyData) {
    memory.wood_needed = memory.wood_needed.max(1) - 1;
    memory.distance_to_trees = 1.0;
  }
}

struct EnemyAttackOpponentTask;

impl Task&lt;EnemyData&gt; for EnemyAttackOpponentTask {
  fn on_enter(&amp;mut self, memory: &amp;mut EnemyData) {
    memory.distance_to_opponent = 1.0;
    memory.opponent_strength = 0.0;
  }
}

// Test run

let mut enemy = Enemy::new();

assert_eq!(enemy.reasoner.active_state(), None);
assert_eq!(enemy.data.hunger, 0.0);
assert_eq!(enemy.data.distance_to_food, 1.0);
assert_eq!(enemy.data.distance_to_trees, 1.0);
assert_eq!(enemy.data.wood_needed, 0);
assert_eq!(enemy.data.distance_to_opponent, 1.0);
assert_eq!(enemy.data.opponent_strength, 0.0);

enemy.data.hunger = 0.5;
enemy.data.distance_to_food = 0.9;
enemy.data.distance_to_trees = 0.5;
enemy.data.opponent_strength = 0.2;

enemy.tick();
assert_eq!(enemy.reasoner.active_state(), Some(&amp;EnemyState::AttackOpponent));
assert_eq!(enemy.data.hunger, 0.5);
assert_eq!(enemy.data.distance_to_food, 0.9);
assert_eq!(enemy.data.distance_to_trees, 0.5);
assert_eq!(enemy.data.wood_needed, 0);
assert_eq!(enemy.data.distance_to_opponent, 1.0);
assert_eq!(enemy.data.opponent_strength, 0.0);

enemy.tick();
assert_eq!(enemy.reasoner.active_state(), Some(&amp;EnemyState::GatherFood));
assert_eq!(enemy.data.hunger, 0.0);
assert_eq!(enemy.data.distance_to_food, 1.0);
assert_eq!(enemy.data.distance_to_trees, 0.5);
assert_eq!(enemy.data.wood_needed, 0);
assert_eq!(enemy.data.distance_to_opponent, 1.0);
assert_eq!(enemy.data.opponent_strength, 0.0);

enemy.data.wood_needed = 1;

enemy.tick();
assert_eq!(enemy.reasoner.active_state(), Some(&amp;EnemyState::GatherWood));
assert_eq!(enemy.data.hunger, 0.0);
assert_eq!(enemy.data.distance_to_food, 1.0);
assert_eq!(enemy.data.distance_to_trees, 1.0);
assert_eq!(enemy.data.wood_needed, 0);
assert_eq!(enemy.data.distance_to_opponent, 1.0);
assert_eq!(enemy.data.opponent_strength, 0.0);

enemy.tick();
assert_eq!(enemy.reasoner.active_state(), Some(&amp;EnemyState::Idle));
assert_eq!(enemy.data.hunger, 0.0);
assert_eq!(enemy.data.distance_to_food, 1.0);
assert_eq!(enemy.data.distance_to_trees, 1.0);
assert_eq!(enemy.data.wood_needed, 0);
assert_eq!(enemy.data.distance_to_opponent, 1.0);
assert_eq!(enemy.data.opponent_strength, 0.0);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typical-use-cases-2"><a class="header" href="#typical-use-cases-2">Typical use cases</a></h1>
<ul>
<li>
<p><strong>Emergent AI behaviors</strong></p>
<p>Best example of the game that uses Utility AI is <strong>The Sims</strong>. You can basically
create a set of actions agent can do depending on its current needs and let
agent chose what's best for him to do at given time by modeling behavior after
<strong>Maslow's hierarchy of needs</strong>.</p>
<p>Rouglike games can use it to make procedurally generated agents perform unique
life-cycles based on PCG agent stats.</p>
<p>Strategy games can use it to let factions and units evaluate certain strategies
that will then be run by other decision makers (using hierarchical approach).</p>
</li>
<li>
<p><strong>Branchless dynamic dialogues</strong></p>
<p>You can bring life to dialogues with NPCs by making NPC choose a line that fits
best current situation and facts about the world. Imagine talking with NPC
before and after result of some major game event or some crazy fact heard about
one of your battles and using that knowledge to drop some comment about it or
ask you questions about what happened.</p>
</li>
<li>
<p><strong>Emergent storytelling and adaptive world events</strong></p>
<p>When making a game focused on replayability your goal is to make player
experience the game differently on each playthrough, for that you might want
to forget about scripted events sequence and let game spawn game events that
based on the game state or even player &quot;fun&quot; score to keep pacing that will
make player engaged.</p>
</li>
</ul>
<p>In general you can use Utility AI to systems that are meant to be unpredictable,
provide unique experience to the player or even produce viral moments for players
to share with others.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="more"><a class="header" href="#more">More...</a></h1>
<p>If you need an explanation of some AI-related problem, consider creating an issue
on github with what you would like to achieve, what problem you would like to
solve but don't know how to tackle it, and at some point it might land in the book.</p>
<p>You can create new issue here: <a href="https://github.com/PsichiX/emergent/issues/new">https://github.com/PsichiX/emergent/issues/new</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
